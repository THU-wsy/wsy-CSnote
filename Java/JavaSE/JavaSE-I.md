# 第01章_Java语言概述

## 1. Java语言概述

### 1.1 Java概述

- Java是`SUN`(Stanford University Network，斯坦福大学网络公司 ) `1995年`推出的一门高级编程语言。
- `詹姆斯·高斯林(James Gosling)`先生以“Java 技术之父”而闻名于世。他是Java 技术的创始人，他亲手设计了Java语言，并开发了Java编译器和Java虚拟机，使Java成为了世界上最流行的开发语言。
- James Gosling于1984 年加入Sun公司，并一直服务于Sun公司，直至2010年前后，Sun被Oracle并购而加入Oracle，担任客户端软件集团的首席技术官; 2010年4月从Oracle离职。

### 1.2 Java技术体系平台

- **Java SE(Java Standard Edition)标准版**
  - 支持面向`桌面级应用`（如Windows下的应用程序）的Java平台，即定位个人计算机的应用开发。
  - 包括用户界面接口AWT及Swing，网络功能与国际化、图像处理能力以及输入输出支持等。
  - 此版本以前称为J2SE
- **Java EE(Java Enterprise Edition)企业版**
  - 为开发企业环境下的应用程序提供的一套解决方案，即定位`在服务器端的Web应用开发`。
  - JavaEE是JavaSE的扩展，增加了用于服务器开发的类库。如：Servlet能够延伸服务器的功能，通过请求-响应的模式来处理客户端的请求；JSP是一种可以将Java程序代码内嵌在网页内的技术。
  - 版本以前称为J2EE
- **Java ME(Java Micro Edition)小型版**
  - 支持Java程序运行在`移动终端（手机、机顶盒）上的平台`，即定位在消费性电子产品的应用开发
  - JavaME是JavaSE的内伸，精简了JavaSE 的核心类库，同时也提供自己的扩展类。增加了适合微小装置的类库：javax.microedition.io.*等。
  - 此版本以前称为J2ME


## 2. Java开发环境搭建

### 2.1 JDK、JRE

![](/zzimages/1660147531310.png)


- **JDK**  (`J`ava `D`evelopment `K`it)：是Java程序开发工具包，包含`JRE` 和开发人员使用的工具。
- **JRE ** (`J`ava `R`untime `E`nvironment) ：是Java程序的运行时环境，包含`JVM` 和运行时所需要的`核心类库`。

> 小结：
>
> JDK = JRE + 开发工具集（例如Javac编译工具等）
>
> JRE = JVM + Java SE标准类库


### 2.2 开发步骤

Java程序开发三步骤：**编写**、**编译**、**运行**。
- 将 Java 代码**编写**到扩展名为 .java 的源文件中
- 通过 javac.exe 命令对该 java 文件进行**编译**，生成一个或多个字节码文件。DOS命令行输入 `javac Java源文件名.java`
- 通过 java.exe 命令对生成的 class 文件进行**运行**。DOS命令行输入 `java 主类名`，从而运行 `主类名.class` 文件。注意主类是指包含main方法的类，main方法是Java程序的入口。

### 2.3 源文件名与类名

（1）源文件名是否必须与类名一致？public呢？

```java
如果这个类不是public，那么源文件名可以和类名不一致。但是不便于代码维护。

如果这个类是public，那么要求源文件名必须与类名一致。否则编译报错。

我们建议大家，不管是否是public，都与源文件名保持一致，而且一个源文件尽量只写一个类，目的是为了好维护。
```

（2）一个源文件中是否可以有多个类？public呢？

```java
一个源文件中可以有多个类，编译后会生成多个.class字节码文件。

但是一个源文件只能有一个public的类。
```


## 3. 注释(comment)


- Java中的注释类型：

  - 单行注释

    ```
    //注释文字
    ```

  - 多行注释

    ```
    /* 
    注释文字1 
    注释文字2
    注释文字3
    */
    ```

  - 文档注释 (Java特有)

    ```
    /**
      @author  指定java程序的作者
      @version  指定源文件的版本
    */ 
    ```

- **文档注释（Java特有）**

  - 文档注释内容可以被JDK提供的工具 javadoc 所解析，生成一套以网页文件形式体现的该程序的说明文档。

  - 操作方式。比如：

    ```
    javadoc -d mydoc -author -version HelloWorld.java
    ```



## 4. Java核心机制：JVM

### 4.1 Java语言的优缺点

Java确实是从C语言和C++语言继承了许多成份，甚至可以将Java看成是类C语言发展和衍生的产物。“青出于蓝，而胜于蓝”。

#### 优点

* **跨平台性**：这是Java的核心优势。Java在最初设计时就很注重移植和跨平台性。比如：Java的int永远都是32位。不像C++可能是16，32，可能是根据编译器厂商规定的变化。
* 通过Java语言编写的应用程序在不同的系统平台上都可以运行。“`Write once , Run Anywhere`”。
* 原理：只要在需要运行 java 应用程序的操作系统上，先安装一个Java虚拟机 (JVM ，`J`ava `V`irtual `M`achine) 即可。由JVM来负责Java程序在该系统中的运行。

* **面向对象性**：

  面向对象是一种程序设计技术，非常`适合大型软件的设计和开发`。面向对象编程支持封装、继承、多态等特性，让程序更好达到`高内聚`，`低耦合`的标准。

* **健壮性**：吸收了C/C++语言的优点，但去掉了其影响程序健壮性的部分（如指针、内存的申请与释放等），提供了一个相对安全的内存管理和访问机制。

* **安全性高**：

  Java适合于网络/分布式环境，需要提供一个安全机制以防恶意代码的攻击。如：`安全防范机制`（ClassLoader类加载器），可以分配不同的命名空间以防替代本地的同名类、字节代码检查。

* **简单性**：

  Java就是C++语法的`简化版`，我们也可以将Java称之为“`C++--`”。比如：头文件，指针运算，结构，联合，操作符重载，虚基类等。

* **高性能**：

  - Java最初发展阶段，总是被人诟病“`性能低`”；客观上，高级语言运行效率总是低于低级语言的，这个无法避免。Java语言本身发展中通过虚拟机的优化提升了`几十倍运行效率`。比如，通过JIT(JUST IN TIME)即时编译技术提高运行效率。


#### 缺点

- `语法过于复杂、严谨`
- 一般适用于大型网站开发，`整个架构会比较重`
- `并非适用于所有领域`。比如，Objective C、Swift在iOS设备上就有着无可取代的地位。浏览器中的处理几乎完全由JavaScript掌控。Windows程序通常都用C++或C#编写。Java在服务器端编程和跨平台客户端应用领域则很有优势。

### 4.2 JVM功能说明

**JVM**（`J`ava `V`irtual `M`achine ，Java虚拟机）：是一个虚拟的计算机，是Java程序的运行环境。JVM具有指令集并使用不同的存储区域，负责执行指令，管理数据、内存、寄存器。


#### 功能1：实现Java程序的跨平台性

我们编写的Java代码，都运行在**JVM** 之上。正是因为有了JVM，才使得Java程序具备了跨平台性。

#### 功能2：自动内存管理(内存分配、内存回收)

- Java程序在运行过程中，涉及到运算的`数据的分配`、`存储`等都由JVM来完成
- Java消除了程序员回收无用内存空间的职责。提供了一种系统级线程跟踪存储空间的分配情况，在内存空间达到相应阈值时，检查并释放可被释放的存储器空间。
- GC的自动回收，提高了内存空间的利用效率，也提高了编程人员的效率，很大程度上`减少了`因为没有释放空间而导致的`内存泄漏`。

> 面试题：
>
> Java程序还会出现内存溢出和内存泄漏问题吗？  Yes!


## 5. 常用的DOS命令

DOS（Disk Operating System，磁盘操作系统）是Microsoft公司在Windows之前推出的一个操作系统，是单用户、单任务（即只能执行一个任务）的操作系统。现在被Windows系统取代。

对于Java初学者，学习一些DOS命令，会非常有帮助。

- 按下Windows+R键盘，打开运行窗口，输入cmd回车，进入到DOS的操作窗口。

**常用指令：**

- `操作1：进入和回退`

| 操作                | 说明                                |
| ------------------- | ----------------------------------- |
| 盘符名称:           | 盘符切换。E:回车，表示切换到E盘。   |
| dir                 | 列出当前目录下的文件以及文件夹      |
| cd 目录             | 进入指定单级目录。                  |
| cd 目录1\目录2\\... | 进入指定多级目录。cd atguigu\JavaSE |
| cd ..               | 回退到上一级目录。                  |
| cd \ 或 cd /        | 回退到盘符目录。                    |

- `操作2：增、删`

| 操作          | 说明                                               |
| ------------- | -------------------------------------------------- |
| md 文件目录名 | 创建指定的文件目录。                               |
| rd 文件目录名 | 删除指定的文件目录（如文件目录内有数据，删除失败） |

- `操作3：其它`

| 操作              | 说明                 |
| ----------------- | -------------------- |
| cls               | 清屏。               |
| exit              | 退出命令提示符窗口。 |
| ←  →              | 移动光标             |
| ↑  ↓              | 调阅历史操作命令     |
| Delete和Backspace | 删除字符             |



# 第02章_变量与运算符

## 1. 关键字（keyword）

定义：**被Java语言赋予了特殊含义，用做专门用途的字符串（或单词）**

>  说明：
>
>  1. 关键字一共`50个`，其中`const`和`goto`是`保留字`(reserved word)。
>  2. `true`，`false`，`null`不在其中，它们看起来像关键字，其实是字面量，表示特殊的布尔值和空值。

## 2. 标识符(identifier)

Java中变量、方法、类等要素命名时使用的字符序列，称为标识符。

**标识符的命名规则**：

```
> 由26个英文字母大小写，0-9 ，_或 $ 组成  
> 数字不可以开头。
> 不可以使用关键字和保留字。
> Java中严格区分大小写，长度无限制。
> 标识符不能包含空格。
```

**标识符的命名规范**:

```
> 包名：多单词组成时所有字母都小写：xxxyyyzzz。
  例如：java.lang、com.atguigu.bean
  
> 类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz
  例如：HelloWorld，String，System等
  
> 变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz
  例如：age,name,bookName,main,binarySearch,getName
  
> 常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ
  例如：MAX_VALUE,PI,DEFAULT_CAPACITY
```


## 3. 基本数据类型介绍

Java中变量的数据类型分为两大类：

- **基本数据类型**：包括 `整数类型`、`浮点数类型`、`字符类型`、`布尔类型`。 

- **引用数据类型**：包括`数组`、 `类`、`接口`、`枚举`、`注解`、`记录`。 

我们先介绍基本数据类型。

![](/zzimages/1660832924103.png)


### 3.1 整数类型：byte、short、int、long

需要我们注意的是，随便写一个整数或者小数的字面量，它是有默认数据类型的(整数默认int，小数默认double)

```
- 比如23，它默认就为int类型；如果加上后缀L，则为long类型；
- 比如23.8，它默认为double类型；如果加上后缀F，则为float类型;
```

注意变量是什么类型，就应该用来装什么类型的数据，否则报错。例如对于 `int age = 0;`，则赋值语句 `age = 9.5` 会报错。

**不同进制在Java程序中的书写格式**：

```java
System.out.pirntln('a' + 1); //98
System.out.pirntln(0b01100001); //97，二进制
System.out.pirntln(0141); //97，八进制
System.out.pirntln(0x61); //97，十六进制
```


### 3.2 浮点类型：float、double

浮点型常量有两种表示形式：

- 十进制数形式。如：5.12 512.0f .512 (必须有小数点)
- 科学计数法形式。如：5.12e2   512E2   100E-2
 
#### 关于浮点型精度的说明

- 并不是所有的小数都能可以精确的用二进制浮点数表示。二进制浮点数不能精确的表示0.1、0.01、0.001这样10的负次幂。

- 浮点类型float、double的数据不适合在`不容许舍入误差`的金融计算领域。如果需要`精确`数字计算或保留指定位数的精度，需要使用`BigDecimal类`。

### 3.3 字符类型：char

char 型数据用来表示通常意义上“`字符`”（占2字节）

Java中的所有字符都使用Unicode编码，故一个字符可以存储一个字母，一个汉字，或其他书面语的一个字符。所以char类型是可以进行运算的，因为它都对应有Unicode码，可以看做是一个数值。

### 3.4 布尔类型：boolean

**boolean类型数据只有两个值：true、false**

- 不可以使用0或非 0 的整数替代false和true，这点和C语言不同。
- 拓展：Java虚拟机中没有任何供boolean值专用的字节码指令，Java语言表达所操作的boolean值，在编译之后都使用java虚拟机中的int数据类型来代替：true用1表示，false用0表示。

## 4. 基本数据类型变量间运算规则

在Java程序中，不同的基本数据类型（只有7种，不包含boolean类型）变量的值经常需要进行相互转换。

转换的方式有两种：`自动类型提升`和`强制类型转换`。

### 4.1 自动类型提升

**规则：将取值范围小（或容量小）的类型自动提升为取值范围大（或容量大）的类型 。**

基本数据类型的转换规则如图所示：

![](/zzimages/1660837456261.png)

（1）当把存储范围小的值（常量值、变量的值、表达式计算的结果值）赋值给了存储范围大的变量时

```java
int i = 'A';//char自动升级为int，其实就是把字符的编码值赋值给i变量了
double d = 10;//int自动升级为double
long num = 1234567; //右边的整数常量值如果在int范围呢，编译和运行都可以通过，这里涉及到数据类型转换

//byte bigB = 130;//错误，右边的整数常量值超过byte范围
long bigNum = 12345678912L;//右边的整数常量值如果超过int范围，必须加L，显式表示long类型。否则编译不通过
```

（2）当存储范围小的数据类型与存储范围大的数据类型变量一起混合运算时，会按照其中最大的类型运算。

```java
int i = 1;
byte b = 1;
double d = 1.0;

double sum = i + b + d;//混合运算，升级为double
```

（3）当byte,short,char数据类型的变量**进行算术运算**时，自动升级为int类型处理。

```java
byte b1 = 1;
byte b2 = 2;
byte b3 = b1 + b2;//编译报错，b1 + b2自动升级为int

char c1 = '0';
char c2 = 'A';
int i = c1 + c2;//至少需要使用int类型来接收
System.out.println(c1 + c2);//113 
```

### 4.2 强制类型转换

**规则：将取值范围大（或容量大）的类型强制转换成取值范围小（或容量小）的类型。**

**转换格式：**

```java
数据类型1 变量名 = (数据类型1)被强转数据值;  //()中的数据类型必须<=变量值的数据类型
```

当把存储范围大的值（常量值、变量的值、表达式计算的结果值）强制转换为存储范围小的变量时，可能会`损失精度`或`溢出`。

```java
int i = (int)3.14;//损失精度

int i = 200;
byte b = (byte)i;//溢出
```


### 4.3 基本数据类型与String的运算


1、任意八种基本数据类型的数据与String类型只能进行连接“+”运算，且结果一定也是String类型

```java
System.out.println("" + 1 + 2);//12

int num = 10;
boolean b1 = true;
String s1 = "abc";

String s2 = s1 + num + b1;
System.out.println(s2);//abc10true

//String s3 = num + b1 + s1;//编译不通过，因为int类型不能与boolean运算
String s4 = num + (b1 + s1);//编译通过

System.out.println('a'+ 1 + "Hello!");//输出：98Hello!
```

2、String类型不能通过强制类型()转换，转为其他的类型

```java
String str = "123";
int num = (int)str;//错误的

int num = Integer.parseInt(str);//正确的，后面才能讲到，借助包装类的方法才能转
```

## 5. 运算符（Operator）

|           分类            |                        运算符                        |
| :-----------------------: | :--------------------------------------------------: |
|     算术运算符（7个）     |                +、-、*、/、%、++、--                 |
|    赋值运算符（12个）     | =、+=、-=、*=、/=、%=、>>=、<<=、>>>=、&=、\|=、^=等 |
| 比较(或关系)运算符（6个） |                 >、>=、<、<=、==、!=                 |
|     逻辑运算符（6个）     |                &、\|、^、!、&&、\|\|                 |
|      位运算符（7个）      |               &、\|、^、~、<<、>>、>>>               |
|     条件运算符（1个）     |               (条件表达式)?结果1:结果2               |
|    Lambda运算符（1个）    |                  ->（第18章时讲解）                  |


### 5.1 算术运算符

```java
/: 两个整数相除，结果也是一个整数
%: 表示两个数相除，取余数。例如 a % b，其结果的符号与a的符号相同
```

例：
```java
int m = 2;
m = m++; //(1)先取b的值“2”放操作数栈 (2)m再自增,m=3 (3)再把操作数栈中的"2"赋值给m,m=2
System.out.println(m); // 2
```

### 5.2 赋值运算符

- 赋值运算符`=`支持连续赋值。
- 扩展的赋值运算符隐含了强制类型转换。例如 `a += b;`，底层代码形式为`a = (a的类型)(a + b);`

```java
问题1：下面的代码否有问题？
    byte x = 10;
    byte y = 30;
	  x = x + y;  //这句代码有问题，因为两个byte类型数据相加，会提升为int类型;
	
问题2：下面的代码是否有问题？
	byte x = 10;
	byte y = 30;
	x += y; //这句代码没有问题，因为这里有隐含的强制类型转换
	//x += y; 等价于 byte x = (byte)(x + y);
```

### 5.3 比较(关系)运算符

比较运算符的结果都是boolean型，也就是要么是true，要么是false。

- \>   <   >=  <= ：只适用于基本数据类型（除boolean类型之外）
- ==   != ：适用于基本数据类型和引用数据类型
- 还有一个特殊的比较运算符`instanceof`，可以检查是否是类的对象。例如`"Hello" instanceof String`的结果是`true`

### 5.4 逻辑运算符


逻辑运算符，操作的都是boolean类型的变量或常量，而且运算得结果也是boolean类型的值。

![](/zzimages/1660873470958.png)

### 5.5 位运算符

![](/zzimages/20220313174721111.png)

![](/zzimages/20220312002506339.png)

位运算符的运算过程都是基于二进制的补码运算

### 5.6 条件运算符

```java
(条件表达式)? 表达式1:表达式2
```

### 5.7 运算符优先级

上一行中的运算符总是优先于下一行的。

| 优先级 |    运算符说明    |             Java运算符             |
| ------ | :--------------: | :--------------------------------: |
| 1      |       括号       |          `()`、`[]`、`{}`          |
| 2      |      正负号      |              `+`、`-`              |
| 3      |    单元运算符    |       `++`、`--`、`~`、`！`        |
| 4      | 乘法、除法、求余 |           `*`、`/`、`%`            |
| 5      |    加法、减法    |              `+`、`-`              |
| 6      |    移位运算符    |         `<<`、`>>`、`>>>`          |
| 7      |    关系运算符    | `<`、`<=`、`>=`、`>`、`instanceof` |
| 8      |    等价运算符    |             `==`、`!=`             |
| 9      |      按位与      |                `&`                 |
| 10     |     按位异或     |                `^`                 |
| 11     |      按位或      |                `|`                 |
| 12     |      条件与      |                `&&`                |
| 13     |      条件或      |                `||`                |
| 14     |    三元运算符    |               `? :`                |
| 15     |    赋值运算符    | `=`、`+=`、`-=`、`*=`、`/=`、`%=`  |
| 16     |   位赋值运算符   |  `&=`、`|=`、`<<=`、`>>=`、`>>>=`  |


# 第03章_流程控制语句

## 1. 分支语句

### 1.1 if分支

### 1.2 switch分支

**使用注意点：**

- switch(表达式)中表达式的值必须是下述几种类型之一：byte，short，char，int，枚举 (jdk 5.0)，String (jdk 7.0)；

- case子句中的值必须是常量，不能是变量名或不确定的表达式值或范围；

- 同一个switch语句，所有case子句中的常量值互不相同；

- 正常使用switch的时候，不要忘记写break，否则会出现穿透现象。

- default子句是可选的。同时，位置也是灵活的。当没有匹配的case时，执行default语句。

## 2. 循环语句

### 2.1 for循环

### 2.2 while循环

### 2.3 do-while循环

### 2.4 关键字break和continue的使用

**带标签的使用方法：**

```java
break语句出现在多层嵌套的语句块中时，可以通过标签指明要终止的是哪一层语句块 
	label1: {   ……        
	label2:	     {   ……
	label3:			 {   ……
				           break label2;
				           ……
					 }
			     }
			} 
```

- continue语句出现在多层嵌套的循环语句体中时，也可以通过标签指明要跳过的是哪一层循环。
- 标号语句必须紧接在循环的头部。标号语句不能用在非循环语句的前面。

- 举例：

```java
class BreakContinueTest2 {
	public static void main(String[] args) {
		l:for(int i = 1;i <= 4;i++){
		
			for(int j = 1;j <= 10;j++){
				if(j % 4 == 0){
					//break l;
					continue l;
				}
				System.out.print(j);
			}
			System.out.println();
		}
	}
}
```


## 3. 补充：Scanner类

- 如何从键盘获取不同类型（基本数据类型、String类型）的变量：使用Scanner类。

- 键盘输入代码的四个步骤：
  1. 导包：`import java.util.Scanner;`
  2. 创建Scanner类型的对象：`Scanner scan = new Scanner(System.in);`
  3. 调用Scanner类的相关方法（`next() / nextXxx()`），来获取指定类型的变量
  4. 释放资源：`scan.close();`
- 注意：需要根据相应的方法，来输入指定类型的值。如果输入的数据类型与要求的类型不匹配时，会报异常导致程序终止。
- 注意：System、String在JDK中的Java.lang包下。lang包不需要我们导包，是默认的包。

**各种类型的数据输入**

```java
//1. 导包
import java.util.Scanner;

public class ScannerTest1 {

    public static void main(String[] args) {
        //2. 创建Scanner的对象
        //Scanner是一个引用数据类型，它的全名称是java.util.Scanner
        //scanner就是一个引用数据类型的变量了，赋给它的值是一个对象
        //new Scanner(System.in)是一个new表达式，该表达式的结果是一个对象
        //System.in默认代表键盘输入
        Scanner scanner = new Scanner(System.in);
        
        //3. 根据提示，调用Scanner的方法，获取不同类型的变量
        System.out.print("请输入你的网名：");
        String name = scanner.next();

        System.out.print("请输入你的年龄：");
        int age = scanner.nextInt();

        System.out.print("请输入你的体重：");
        double weight = scanner.nextDouble();

        System.out.print("你是否单身（true/false)：");
        boolean isSingle = scanner.nextBoolean();

        System.out.print("请输入你的性别：");
        char gender = scanner.next().charAt(0);//先按照字符串接收，然后再取字符串的第一个字符（下标为0）
        
        //4. 关闭资源
        scanner.close();
    }
}
```

## 4. 补充：随机数

### 4.1 Math类

1、Math类的random()的调用，会返回一个`[0,1)`范围的一个double型值

2、如何获取`[a,b]`范围内的随机整数呢？`(int)(Math.random() * (b - a + 1)) + a`

### 4.2 Random类

`Random` 类下的 `nextInt(n)` 方法能生成 `0` 至 `n-1` 之间的随机数，不包含 `n`

```java
import java.util.Random;
public class RandomDemo1 {
    public static void main(String[] args) {
        // 创建一个Random对象，用于生成随机数。
        Random r = new Random();
        // 调用Random提供的功能：nextInt得到随机数。
        for (int i = 1; i <= 20; i++) {
            int data = r.nextInt(10); // 0 - 9
            System.out.println(data);
        }
    }
}
```

要生成`[M, N]`之间的随机数，有两种方案：

```java
// 方案一：
Random r = new Random();
int ans = r.nextInt(N - M + 1) + M;
```

```java
// 方案二：直接调用java提供的API : r.nextInt(a, b) 生成[a, b)之间的随机整数
ans = r.nextInt(M, N + 1);
```

# 第05章_数组

## 1. 数组的概述

数组(Array)，是多个相同类型数据按一定顺序排列的集合，并使用一个名字命名，并通过编号的方式对这些数据进行统一管理。

**数组的特点：**

- 数组本身是`引用数据类型`，而数组中的元素可以是`任何数据类型`，包括基本数据类型和引用数据类型。
- 创建数组对象会在内存中开辟一整块`连续的空间`。占据的空间的大小，取决于数组的长度和数组中元素的类型。
- 数组，一旦初始化完成，其长度就是确定的。数组的`长度一旦确定，就不能修改`。
- 我们可以直接通过下标(或索引)的方式调用指定位置的元素，速度很快。
- 数组名中引用的是这块连续空间的首地址。


## 2. 一维数组的使用

### 2.1 一维数组的声明

**格式：**

```java
//推荐
元素的数据类型[] 一维数组的名称;

//不推荐
元素的数据类型  一维数组名[];
```

**数组的声明，需要明确：**

（1）数组的维度：在Java中数组的符号是[]，[]表示一维，\[]\[]表示二维。

（2）数组的元素类型：即创建的数组容器可以存储什么数据类型的数据。

（3）数组名：就是代表某个数组的标识符，是个引用数据类型的变量，因为它代表一组数据。

注意：Java语言中声明数组时不能指定其长度(数组中元素的个数)。 例如： `int a[5]; //非法`

### 2.2 一维数组的初始化

#### 2.2.1 静态初始化

如果数组变量的初始化和数组元素的赋值操作同时进行，那就称为静态初始化。静态初始化，本质是用静态数据（编译时已知）为数组初始化，此时数组的长度由静态数据的个数决定。
  
- **一维数组声明和静态初始化格式1：**

  ```java
  // 方式1
  int[] arr1 = new int[]{1, 2, 3};
  // 方式2
  int[] arr2;
  arr2 = new int[]{1, 2, 3};
  ```

  - new：关键字，创建数组使用的关键字。因为数组本身是引用数据类型，所以要用new创建数组实体。


- **一维数组声明和静态初始化格式2：**

  ```java
  int[] arr3 = {1, 2, 3};//必须在一个语句中完成，不能分成两个语句写
  ```

#### 2.2.2 动态初始化

数组变量的初始化和数组元素的赋值操作分开进行，即为动态初始化。动态初始化中，只确定了元素的个数（即数组的长度），而元素值此时只是默认值，还并未真正赋自己期望的值。真正期望的数据需要后续单独一个一个赋值。

**格式：**

```java
// 方式1
int[] arr1 = new int[3];
// 方式2
int[] arr2;
arr2 = new int[3];
```

**注1**：直接打印数组名，并不会打印数组的真实内容。

```java
System.out.println(arr2); // [I@4eec7777
```

**注2**：静态初始化和动态初始化数组的写法是独立的，不可以混用。如下写法是错误的：

```java
int[] arr = new int[3]{30，40, 50};
```

**注3**：使用动态初始化定义数组时，根据元素类型不同，默认值也有所不同。

![](/zzimages/1661417981361.png)

**注4**：数组的长度可以用 `arr.length` 获取


## 3. 一维数组内存分析

### 3.1 Java虚拟机的内存划分

为了提高运算效率，就对空间进行了不同区域的划分，因为每一片区域都有特定的处理数据方式和内存管理方式。

![](/zzimages/jvmjgjt666.png)

| 区域名称   | 作用                                                      |
| ----------| ---------------------------------------------------------|
| `虚拟机栈` | 用于存储正在执行的每个Java方法的局部变量表等。局部变量表存放了编译期可知长度的各种基本数据类型、对象引用，方法执行完，自动释放。|
| `堆内存` | 存储对象（包括数组对象），new来创建的，都存储在堆内存。 |
| `方法区` | 存储已被虚拟机加载的类信息、常量、（静态变量）、即时编译器编译后的代码等数据。 |
| 本地方法栈 | 当程序中调用了native的本地方法时，本地方法执行期间的内存区域 |
| 程序计数器 | 程序计数器是CPU中的寄存器，它包含每一个线程下一条要执行的指令的地址 |

### 3.2 一维数组在内存中的存储

![](/zzimages/1661438278304.png)

在实际开发中可能存在一种特殊情况，就是多个变量指向同一个数组对象的形式。


```java
public class ArrayDemo2 {
    public static void main(String[] args) {
        int[] arr1 = {11, 22, 33};
        // 把int类型的数组变量arr1赋值给int类型的数组变量arr2
        int[] arr2 = arr1;

        System.out.println(arr1); // [I@4eec7777
        System.out.println(arr2); // [I@4eec7777

        arr2[1] = 99;
        System.out.println(arr1[1]); // 99

        arr2 = null; // 拿到的数组变量中存储的值是null
        System.out.println(arr2); // null
        System.out.println(arr1); // [I@4eec7777
    }
}
```

**总结：**

- 两个变量指向同一个数组时，两个变量记录的是同一个地址值。

- 当一个变量修改数组中的元素时，另一个变量去访问数组中的元素，元素已经被修改过了。

- 如果某个数组变量存储的地址是null，那么该变量将不再指向任何数组对象，此时只能打印出 `null`，但无法获得 `length` 等属性

**补充(对象数组)**：

数组的元素可以是基本数据类型，也可以是引用数据类型。当元素是引用类型中的类时，我们称为对象数组。注意创建对象数组，首先要创建数组对象本身，即确定数组的长度，然后再创建每一个元素对象，如果不创建，数组的元素的默认值就是 null ，所以很容易出现空指针异常 `NullPointerException` 。


## 4. 多维数组的使用

### 4.1 概述

Java 语言里提供了支持多维数组的语法。

> - 对于二维数组的理解，可以看成是一维数组array1又作为另一个一维数组array2的元素而存在。
> - 其实，从数组底层的运行机制来看，其实没有多维数组。

### 4.2 声明与初始化

#### 4.2.1 声明

二维数组声明的语法格式：

```java
//推荐
int[][] arr;

//不推荐
int arr[][];
//不推荐
int[] arr[];
```

例：

```java
int[] x, y[]; //x是一维数组，y是二维数组
```

#### 4.2.2 静态初始化

**格式：**

```java
int[][] arr = new int[][]{{3,8,2},{2,7},{9,0,1,6}};
```

定义一个名称为arr的二维数组，二维数组中有三个一维数组

- 每一个一维数组中具体元素也都已初始化
  - 第一个一维数组 `arr[0] = {3,8,2};`
  - 第二个一维数组 `arr[1] = {2,7};`
  - 第三个一维数组 `arr[2] = {9,0,1,6};`
- 第三个一维数组的长度表示方式：`arr[2].length;`


其他类似方式：

```java
int[][] arr2;
arr = new int[][]{{1,2,3},{4,5,6},{7,8,9,10}};

int[][] arr3 = {{1,2,3},{4,5,6},{7,8,9,10}};//声明与初始化必须在一句完成
```

#### 4.2.3 动态初始化

动态初始化方式分为两种格式：

**格式1：规则二维表：每一行的列数是相同的**

```java
//（1）确定行数和列数
int[][] arr = new int[m][n];
	//其中，m表示这个二维数组有多少个一维数组，或者说一共二维表有几行
	//其中，n表示每一个一维数组的元素有多少个，或者说每一行共有几个单元格

//此时创建完数组，行数、列数确定，而且元素也都有默认值
//（2）然后再为元素赋值
```

**格式2：不规则：每一行的列数不一样**

```java
//（1）先确定总行数m
int[][] arr = new int[m][];

//此时只是确定了总行数，每一行里面现在是null

//（2）再确定每一行的列数，创建每一行的一维数组
arr[0] = new int[n1];
arr[1] = new int[n2];
...
//此时已经new完的行的元素就有默认值了，没有new的行还是null
//（3）最后再为元素赋值
```

注：`int[][] arr = new int[][3]; //非法`

### 4.3 数组的长度和角标

- 二维数组的长度/行数：`二维数组名.length`
- 某一行的列数：`二维数组名[行下标].length`，因为二维数组的每一行是一个一维数组。

## 5. Arrays工具类

java.util.Arrays类即为操作数组的工具类，包含了用来操作数组（比如排序和搜索）的各种方法。 

**数组元素拼接**
  * `static String toString(int[] a)` ：字符串表示形式由数组的元素列表组成，括在方括号（`"[]"`）中。相邻元素用字符 `", "`（逗号加空格）分隔。形式为：`[元素1, 元素2, 元素3, ...]`
  * `static String toString(Object[] a)` ：字符串表示形式由数组的元素列表组成，括在方括号（`"[]"`）中。相邻元素用字符 `", "`（逗号加空格）分隔。元素将自动调用自己从Object继承的toString方法将对象转为字符串进行拼接，如果没有重写，则返回类型@hash值，如果重写则按重写返回的字符串进行拼接。

**数组排序**
  * `static void sort(int[] a)` ：将a数组按照从小到大进行排序(快速排序)
  * `static void sort(int[] a, int fromIndex, int toIndex)` ：将a数组的`[fromIndex, toIndex)`部分按照升序排列(快速排序)
  * `static void sort(Object[] a)` ：根据元素的自然顺序对指定对象数组按升序进行排序(快速排序)
  * `static <T> void sort(T[] a, Comparator<? super T> c)` ：根据指定比较器产生的顺序对指定对象数组进行排序(快速排序)

**数组元素的二分查找**
  * `static int binarySearch(int[] a, int key)`  、`static int binarySearch(Object[] a, Object key)` ：要求数组有序，在数组中查找key是否存在，如果存在返回第一次找到的下标，不存在则返回负数。

**数组的复制**
  * `static int[] copyOf(int[] original, int newLength)` ：根据original原数组复制一个长度为newLength的新数组，并返回新数组
  * `static <T> T[] copyOf(T[] original, int newLength)`：根据original原数组复制一个长度为newLength的新数组，并返回新数组
  * `static int[] copyOfRange(int[] original, int from, int to)` ：复制original原数组的`[from,to)`构成新数组，并返回新数组
  * `static <T> T[] copyOfRange(T[] original,int from,int to)`：复制original原数组的`[from,to)`构成新数组，并返回新数组

**比较两个数组是否相等**
  * `static boolean equals(int[] a, int[] a2)` ：比较两个数组的长度、元素是否完全相同
  * `static boolean equals(Object[] a, Object[] a2)`：比较两个数组的长度、元素是否完全相同

**填充数组**
  * `static void fill(int[] a, int val)` ：用val值填充整个a数组
  * `static void fill(Object[] a, Object val)`：用val对象填充整个a数组
  * `static void fill(int[] a, int fromIndex, int toIndex, int val)`：将a数组`[fromIndex,toIndex)`部分填充为val值
  * `static void fill(Object[] a, int fromIndex, int toIndex, Object val)` ：将a数组`[fromIndex,toIndex)`部分填充为val对象

**批量修改数组内容**
  * `static void setAll(double[] array, IntToDoubleFunction generator)`：把数组中的原数据改为新数据。

举例：
```java
double[] prices = {99.8, 128, 100};
Arrays.setAll(prices, i -> prices[i] * 10.0);
System.out.println(Arrays.toString(prices)); // [998.0, 1280.0, 1000.0]
```


# 第06章_面向对象编程(基础)

## 1. 面向对象编程概述

- **Java类的成员：属性、方法、构造器、代码块、内部类**
- **面向对象的特征：封装、继承、多态、（抽象）**

类(Class) 和 对象(Object) 是面向对象的核心概念。

**类**：具有相同特征的事物的抽象描述，是**抽象的**、概念上的定义。

**对象**：实际存在的该类事物的每个个体，是**具体的**，因而也称为**实例**(instance) 。

类，是一组相关属性和行为的集合，这也是类最基本的两
个成员。成员变量(属性，field)，成员方法(函数，method)。

**补充(匿名对象)**：我们也可以不定义对象的句柄，而直接调用这个对象的方法，这样的对象叫做匿名对象。如`new Person().shout();`。我们经常将匿名对象作为实参传递给一个方法调用。

## 2. 对象的内存解析

- 堆（Heap）：此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配。

- 栈（Stack）：是指虚拟机栈。虚拟机栈用于存储局部变量等。局部变量表存放了编译期可知长度的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不等同于对象本身，是对象在堆内存的首地址）。方法执行完，自动释放。

- 方法区（Method Area）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

按照我们之前讲的数组的执行原理，数组变量记录的其实数数组在堆内存中的地址。其实面向对象的代码执行原理和数组的执行原理是非常类似的。

`Student s1 = new Student();`这句话中的原理如下

- `Student s1`表示的是在栈内存中，创建了一个Student类型的变量，变量名为s1

- 而`new Student()`会在堆内存中创建一个对象，而对象中包含学生的属性名和属性值。同时系统会为这个Student对象分配一个地址值 `0x4f3f5b24`

- 接着把对象的地址赋值给栈内存中的变量s1，通过s1记录的地址就可以找到这个对象

- 当执行`s1.name="播妞"`时，其实就是通过s1找到对象的地址，再通过对象找到对象的name属性，再给对象的name属性赋值为`播妞`;  

![](/zzimages/1662213744520.png)

直接打印对象名和数组名都是显示`类型@对象的hashCode值`，所以说类、数组都是引用数据类型，引用数据类型的变量中存储的是对象的地址，或者说指向堆中对象的首地址。

**注1**：一个代码文件中，可以写多个class类，但是只能有一个是public修饰，且public修饰的类必须和文件名相同。

**注2**：对象与对象之间的数据不会相互影响，但是多个变量指向同一个对象会相互影响。

**注3**：当堆内存中的对象，没有被任何变量引用（指向）时，就会被判定为内存中的“垃圾”。Java存在自动垃圾回收机制(GC)，会自动清除掉垃圾对象，程序员不用操心，注意只有在堆内存和方法区中有GC(且堆内存的GC执行的更频繁)，而栈空间中没有GC。



## 3. 类的成员之一：成员变量(field)

**成员变量和局部变量的区别**

- 类中位置不同：成员变量在类中，方法外；而局部变量在方法内。
- 初始化值不同：实例变量有默认值；而局部变量没有默认值，使用之前必须完成赋值。
- 内存位置不同：实例变量在堆内存中；局部变量在栈内存中。
- 作用域不同：实例变量作用域是整个对象；而局部变量作用域是在所归属的大括号中。
- 生命周期不同：实例变量与对象共存亡；而局部变量随着方法的调用而生，随着方法的运行结束而亡。

**注**：实例变量可以显式赋值，也可以不赋值(使用默认值)

## 4. 类的成员之二：成员方法(method)

方法是一种语法结构，它可以把一段代码封装成一个功能，以便重复调用。Java里的方法不能独立存在，所有的方法必须定义在类里。

### 4.1 方法声明和调用

```java
[修饰符] 返回值类型 方法名(形参列表) [throws 异常列表] {
方法体的功能代码
}
```

一个完整的方法包含方法头(也称为方法签名)和方法体。方法的修饰符有很多，如public、protected、private、static、abstract、native、final、synchronized等。

**注意事项**：

1. 形参列表可以有多个，甚至可以没有；如果有多个形参，多个形参必须用 `,` 隔开，且不能给初始化值。

2. 如果返回值类型不是void，方法体中必须保证一定有 `return 返回值;` 语句，并且要求该返回值结果的类型与声明的返回值类型一致或兼容。

3. 如果返回值类型为void时，方法体中可以没有return语句，如果要用return语句提前结束方法的执行，那么return后面不能跟返回值，直接`写return ;` 即可。

4. return语句后面就不能再写其他代码了，否则会报错：Unreachable code

5. 方法在类中没有先后顺序。方法中可以调用类中的方法或属性，不可以在方法内部定义方法。

6. 方法不调用就不会执行，调用方法时，传给方法的数据，必须严格匹配方法的参数情况。


### 4.2 方法调用内存分析

- 方法**没有被调用**的时候，都在**方法区**中的字节码文件(.class)中存储。
- 方法**被调用**的时候，需要进入到**栈内存**中运行。方法每调用一次就会在栈中有一个**入栈**动作，即给当前方法开辟一块独立的栈内存区域，用于存储当前方法的局部变量的值。
- 当方法执行结束后，会释放该内存，称为**出栈**，如果方法有返回值，就会把结果返回调用处，如果没有返回值，就直接结束，回到调用处继续执行下一条指令。

### 4.3 方法重载（overload）

方法重载：在同一个类中，允许存在一个以上的同名方法，只要它们的参数列表不同即可(参数列表不同，意味着参数个数或参数类型的不同)

重载方法调用：JVM通过方法的参数列表，调用匹配的方法。

- 先找个数、类型最匹配的
- 再找个数和类型可以兼容的，如果同时多个方法可以兼容将会报错

下面案例中有多个test方法，但是参数列表都不一样，它们都是重载的方法。调用时只需要通过参数来区分即可。

```java
public class MethodOverLoadDemo1 {
    public static void main(String[] args) {
        test();
        test(100);
    }

    public static void test(){
        System.out.println("===test1===");
    }

    public static void test(int a){
        System.out.println("===test2===" + a);
    }

    void test(double a){
    }

    void test(double a, int b){
    }

    void test(int b, double a){
    }

    int test(int a, int b){
        return a + b;
    }
}
```

注意：`println` 有一个特殊的重载，参数为 `char[]`，从而使得打印 `char[]` 数组时能够打印其具体内容，如下所示：

```java
int[] arr1 = {1, 2, 3};
System.out.println(arr1); // [I@4eec7777
char[] arr2 = {'a', 'b', 'c', 'd'};
System.out.println(arr2); // abcd
```

### 4.4 可变个数的参数

在JDK 5.0 中提供了Varargs(variable number of arguments)机制。即当定义一个方法时，形参的类型可以确定，但是形参的个数不确定，那么可以考虑使用可变个数的形参。格式：`方法名(参数的类型名 ... 参数名)`

特点：

- 可变参数部分指定类型的参数个数是可变多个：0个，1个或多个，也可以传一个数组给它
- 可变个数形参的方法与同名的方法之间，可以彼此构成重载
- 可变参数方法的使用与方法参数部分使用数组是一致的，二者不能同时声明，否则报错。因为可变参数在方法内部，本质上就是一个数组。
- 方法的参数部分有可变形参，需要放在形参声明的最后。
- 在一个方法的形参中，最多只能声明一个可变个数的形参。

```java
public class ParamTest{
    public static void main(String[] args) {
        test(); // 0 []
        test(10, 20, 30); // 3 [10, 20, 30]
        int[] arr = new int[]{10, 20, 30, 40};
        test(arr); // 4 [10, 20, 30, 40]
    }

    // 以下方法本质上就是 test(int[] nums)
    public static void test(int ... nums){
        //可变参数在方法内部，本质上是一个数组
        System.out.println(nums.length);
        System.out.println(Arrays.toString(nums));
    }
}
```

### 4.5 Java中方法的参数传递机制：值传递

Java里方法的参数传递方式只有一种：**值传递**。即将实际参数值的副本（复制品）传入方法内，而参数本身不受影响。

- 形参是基本数据类型：将实参基本数据类型变量中存储的**数据值**传递给形参
- 形参是引用数据类型：将实参引用数据类型变量中存储的**地址值**传递给形参

例：数组拷贝

```java
// 注意：int[] arr2 = arr; 这个不是拷贝数组，叫把数组变量赋值给另一个数组变量。
public static int[] copy(int[] arr){
    // 1、创建一个长度一样的整型数组出来。
    int[] arr2 = new int[arr.length];

    // 2、把原数组的元素值对应位置赋值给新数组。
    for (int i = 0; i < arr.length; i++) {
        arr2[i] = arr[i];
    }
    return arr2;
}
```

## 5. 关键字：package、import

### 5.1 package(包)

package，称为包，用于指明该文件中定义的类、接口等结构所在的包。

#### 5.1.1 语法格式

```java
package 顶层包名.子包名;
```

- 一个源文件只能有一个声明包的package语句
- package语句作为Java源文件的第一条语句出现。若缺省该语句，则指定为无名包。
- 包名，属于标识符，满足标识符命名的规则和规范（全部小写）、见名知意
  - 包通常使用所在公司域名的倒置：`com.atguigu.xxx`
  - 取包名时不要使用 `java.xx` 
- 包对应于文件系统的目录，package语句中用 `.` 来指明包(目录)的层次，每 `.` 一次就表示一层文件目录
- 同一个包下可以声明多个结构（类、接口），但是不能定义同名的结构（类、接口）。不同的包下可以定义同名的结构（类、接口）。

#### 5.1.2 包的作用

- 包可以包含类和子包，划分项目层次，便于管理
- 帮助管理大型软件系统：将功能相近的类划分到同一个包中。比如：MVC的设计模式
- 解决类命名冲突的问题
- 控制访问权限

#### 5.1.3 应用举例

**MVC设计模式**

MVC是一种软件构件模式，目的是为了降低程序开发中代码业务的耦合度。MVC设计模式将整个程序分为三个层次： 视图模型(Viewer)层 ， 控制器(Controller)层 ，与 数据模型(Model)层 。这种将程序输入输出、数据处理，以及数据的展示分离开来的设计模式使程序结构变的灵活而且清晰，同时也描述了程序各个对象间的通信方式，降低了程序的耦合性。

``` java
视图层viewer：显示数据，为用户提供使用界面，与用户直接进行交互。
  >相关工具类 view.utils
  >自定义view view.ui
控制层controller：解析用户请求，处理业务逻辑，给予用户响应
  >应用界面相关 controller.activity
  >存放fragment controller.fragment
  >显示列表的适配器 controller.adapter
  >服务相关的 controller.service
  >抽取的基类 controller.base
模型层model：主要承载数据、处理数据
  >数据对象封装 model.bean/domain
  >数据库操作类 model.dao
  >数据库 model.db
```

#### 5.1.4 JDK中主要的包介绍

- `java.lang`：包含一些Java语言的核心类，如String、Math、Integer、System和Thread，提供常用功能
- `java.net`：包含执行与网络相关的操作的类和接口。
- `java.io`：包含能提供多种输入/输出功能的类。
- `java.util`：包含一些实用工具类，如定义系统特性、接口的集合框架类、使用与日期日历相关的函数。
- `java.text`：包含了一些java格式化相关的类
- `java.sql`：包含了java进行JDBC数据库编程的相关类/接口
- `java.awt`：包含了构成抽象窗口工具集（abstract window toolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面(GUI)。

### 5.2 import(导入)

为了使用定义在其它包中的Java类，需用import语句来显式引入指定包下所需要的类。相当于import语句告诉编译器到哪里去寻找这个类。

**语法格式**：

```java
import 包名.类名;
```

**注意事项**：

- import语句，声明在包的声明和类的声明之间。
- 如果需要导入多个类或接口，那么就并列显式多个import语句即可
- 如果使用 `a.*` 导入结构，表示可以导入a包下的所有的结构。举例：可以使用`java.util.*`的方式，一次性导入util包下所有的类或接口。
- 如果导入的类或接口是`java.lang`包下的，或者是当前包下的，则可以省略此import语句。
- 如果已经导入`java.a`包下的类，那么如果需要使用a包的子包下的类的话，仍然需要导入。
- 如果在代码中使用不同包下的同名的类，那么就需要使用类的全类名的方式指明调用的是哪个类。例如 `java.util.Date date1 = null; java.sql.Date date2 = new java.sql.Date(666);`
- （了解） import static 组合的使用：调用指定类或接口下的静态的属性或方法

## 6. 面向对象特征一：封装性(encapsulation)

面向对象的开发原则要遵循**高内聚、低耦合**。高内聚、低耦合是软件工程中的概念，也是UNIX操作系统设计的经典原则。内聚，指一个模块内各个元素彼此结合的紧密程度；耦合指一个软件结构内不同模块之间互连程度的度量。内聚意味着重用和独立，耦合意味着多米诺效应牵一发动全身。而“高内聚，低耦合”的体现之一：

- 高内聚：类的内部数据操作细节自己完成，不允许外部干涉
- 低耦合：仅暴露少量的方法给外部使用，尽量方便外部调用


**封装**：就是把客观事物封装成抽象概念的类，并且类可以把自己的数据和方法只向可信的类或者对象开放，向没必要开放的类或者对象隐藏信息。封装性的设计思想通俗来讲，就是：**合理隐藏、合理暴露**。

### 6.1 权限修饰符

实现封装就是控制类或成员的可见性范围，这就需要依赖访问控制修饰符，也称为权限修饰符来控制。每一种权限修饰符能够被访问的范围如下

|修饰符|本类内部|本包内|其他包的子类|其他包非子类|
|---|----|----|------|-------|
|private|√|×|×|×|
|缺省|√|√|×|×|
|protected|√|√|√|×|
|public|√|√|√|√|


**具体修饰的结构**：

- 外部类：只能使用 public、缺省。**因此外部类要跨包使用必须是public**，否则仅限于本包使用。
- 成员变量、成员方法、构造器、成员内部类：public、protected、缺省、private

### 6.2 封装性的体现

**成员变量/属性 私有化**

一般私有化类的成员变量，提供公共的get和set方法，对外暴露获取和修改属性的功能。

成员变量封装的好处：

- 让使用者只能通过事先预定的方法来访问数据，从而可以在该方法里面加入控制逻辑，限制对成员变量的不合理访问。还可以进行数据检查，从而有利于保证对象信息的完整性。
- 便于修改，提高代码的可维护性。主要说的是隐藏的部分，在内部修改了，如果其对外可以的访问方式不变的话，外部根本感觉不到它的修改。

**私有化方法**

- 一般将类中不需要对外暴露的方法，也进行私有化。
- 单例模式中将构造器设置为private，从而避免在类的外部创建实例。

**注意**：

- 开发中，一般成员实例变量都习惯使用private修饰，再提供相应的public权限的get/set方法访问。
- 对于final的实例变量，不提供set()方法。
- 对于static final的成员变量，习惯上使用public修饰


## 7. 类的成员之三：构造器(Constructor)

### 7.1 构造器的特点

```java
[修饰符] class 类名{
    [修饰符] 构造器名(){
        // 实例初始化代码
    }
    [修饰符] 构造器名(参数列表){
        // 实例初始化代码
    }
}
```

构造器(Constructor)，也称为构造方法，主要作用是在new对象的时候为实例变量赋值，**new 对象就是在执行构造方法**。

**特点**：

- 构造器名必须与它所在的类名必须相同；它没有返回值，也不能写void，且不能有return语句返回值。
- 构造器的修饰符只能是权限修饰符，不能被其他任何修饰。比如，不能被static、final、synchronized、abstract、native修饰。

**注意**：

- 当我们没有显式的声明类中的构造器时，系统会**默认提供**一个无参的构造器，并且该构造器的修饰符默认与类的修饰符相同。所以在类中，至少会存在一个构造器。
- 当我们显式的定义类的构造器以后，系统就不再提供默认的无参的构造器了。此时如果没有定义无参构造器，建议自己加一个无参构造器。
- 构造器是可以重载的。




## 8. 补充

### 8.1 实体类JavaBean

JavaBean是一种Java语言写成的可重用组件。所谓JavaBean，是指符合如下标准的Java类：

- 类是公共的
- 有一个无参的公共的构造器
- 有属性(权限要求private)，且有对应的get、set方法

**实体类仅仅只是用来封装数据用的**。用户可以使用JavaBean将功能、处理、值、数据库访问和其他任何可以用Java代码创造的对象进行打包，并且其他的开发者可以通过内部的JSP页面、Servlet、其他JavaBean、applet程序或者应用来使用这些对象。用户可以认为JavaBean提供了一种随时随地的复制和粘贴的功能，而不用关心任何改变。

### 8.2 UML类图

UML（Unified Modeling Language，统一建模语言），用来描述软件模型和架构的图形化语言。在软件开发中，使用 UML类图 可以更加直观地描述类内部结构（类的属性和操作）以及类之间的关系（如关联、依赖、聚合等）。

- `+`表示 public 类型， `-` 表示 private 类型，`#`表示protected类型
- 方法的写法: 方法的类型(+、-) 方法名(参数名：参数类型)：返回值类型
- 斜体表示抽象方法或类

![](/zzimages/20230711173631.png)




# 第07章_面向对象编程(进阶)

## 1. 关键字：this

### 1.1 this是什么

this 在方法（准确的说是实例方法或非static的方法）内部使用，表示调用该方法的对象。this 在构造器内部使用，表示该构造器正在初始化的对象。

简而言之，哪一个对象调用方法，方法中的this就是哪一个对象。事实上在底层，哪一个对象调用方法，该方法会默认地添加一个this参数，然后把该对象的地址值传入this。

this可以调用的结构：**成员变量、方法和构造器**

### 1.2 this的使用

#### 1.2.1 实例方法或构造器中使用当前对象的成员

在实例方法或构造器中，如果使用当前类的成员变量或成员方法可以在其前面添加this，增强程序的可读性。不过，通常我们都习惯省略this。

但是，当形参与成员变量同名时，如果在方法内或构造器内需要使用成员变量，必须添加this来表明该变量是类的成员变量。即：我们可以用this来区分`成员变量`和`局部变量`。比如：

另外，使用this访问属性和方法时，如果在本类中未找到，会从父类中查找。这个在继承中会讲到。

#### 1.2.2 同一个类中构造器互相调用

this可以作为一个类中构造器相互调用的特殊格式。

- `this()`：调用本类的无参构造器
- `this(实参列表)`：调用本类的有参构造器

```java
public class Student {
    private String name;
    private int age;

    public Student() {

    }
    public Student(String name) {
        this();//调用本类无参构造器
        this.name = name;
    }
    public Student(String name,int age){
        this(name);//调用本类中有一个String参数的构造器
        this.age = age;
    }
}
```

**注意**：

- 不能出现递归调用。比如，调用自身构造器。推论：如果一个类中声明了n个构造器，则最多有n-1个构造器中使用了`this(形参列表)`
- this()和this(实参列表)只能声明在构造器首行。推论：在类的一个构造器中，最多只能声明一个`this(参数列表);`


## 2. 面向对象特征二：继承(Inheritance)

### 2.1 继承的好处

- 继承的出现减少了代码冗余，提高了代码的复用性。

- 继承的出现，更有利于功能的扩展。

- 继承的出现让类与类之间产生了`is-a`的关系，为多态的使用提供了前提。

- 继承描述事物之间的所属关系，这种关系是：`is-a` 的关系。可见，父类更通用、更一般，子类更具体。

> 注意：不要仅为了获取其他类中某个功能而去继承！

### 2.2 继承的语法

通过 `extends` 关键字，可以声明一个类B继承另外一个类A，定义格式如下：

```java
[修饰符] class 类A {
	...
}

[修饰符] class 类B extends 类A {
	...
}
```

- 类B，称为子类、派生类(derived class)、SubClass
- 类A，称为父类、超类、基类(base class)、SuperClass

### 2.3 继承的细节说明

**1、子类会继承父类所有的实例变量和实例方法**

- 当子类对象被创建时，在堆中给对象申请内存时，就要看子类和父类都声明了什么实例变量，这些实例变量都要分配内存。
- 当子类对象调用方法时，编译器会先在子类模板中看该类是否有这个方法，如果没找到，会看它的父类甚至父类的父类是否声明了这个方法，遵循`从下往上`找的顺序，找到了就停止，一直到根父类都没有找到，就会报编译错误。

**2、子类不能直接访问父类中私有的(private)的成员变量和方法**

子类虽会继承父类私有(private)的成员变量，但子类不能对继承的私有成员变量直接进行访问，可通过继承的get/set方法进行访问。

**3、在Java中，继承的关键字用的是“extends”，即子类不是父类的子集，而是对父类的“扩展”**

子类在继承父类以后，还可以定义自己特有的方法，这就可以看做是对父类功能上的扩展。

**4、Java支持多层继承(继承体系)**

```java
class A{}
class B extends A{}
class C extends B{}
```

> 说明：
>
> - 子类和父类是一种相对的概念
>
> - 顶层父类是Object类。所有的类默认继承Object，作为父类。

**5、Java只支持单继承(一个类只能继承一个类)，不支持多重继承**

```java
public class A{}
class B extends A{}

//一个类只能有一个直接父类，不可以有多个直接父类。
class C extends B{} 	//ok
class C extends A,B...	//error
```


### 2.4 方法的重写(override)

父类的所有方法子类都会继承，但是当某个方法被继承到子类之后，子类觉得父类原来的实现不适合于自己当前的类，子类就可以对从父类中继承来的方法进行改造，我们称为方法的`重写 (override、overwrite)`。也称为方法的`重置`、`覆盖`。

在程序执行时，子类的方法将覆盖父类的方法。

```java
class A {
    public void print1(){
        System.out.println("111");
    }
    public void print2(){
        System.out.println("222");
    }
}
class B extends A{
    // 以下是方法重写
    @Override // 安全，可读性好
    public void print1(){
        System.out.println("666");
    }
    // 以下是方法重载
    public void print2(int a) {
        System.out.println("222" + a);
    }
}
```

**注意事项**：

> @Override使用说明：
>
> 写在方法上面，用来检测是不是满足重写方法的要求。这个注解就算不写，只要满足要求，也是正确的方法覆盖重写。建议保留，这样编译器可以帮助我们检查格式，另外也可以让阅读源代码的程序员清晰的知道这是一个重写的方法。

1. 子类重写的方法`必须`和父类被重写的方法具有相同的`方法名称`、`参数列表`。

2. 子类重写的方法的返回值类型`不能大于`父类被重写的方法的返回值类型。（例如：Student < Person）。

> 注意：如果返回值类型是基本数据类型和void，那么必须是相同

3. 子类重写的方法使用的访问权限`不能小于`父类被重写的方法的访问权限。（public > protected > 缺省 > private）

> 注意：1.父类私有方法、静态方法不能重写 2.跨包的父类缺省的方法也不能重写

4. 对于编译时异常，子类方法抛出的异常不能大于父类被重写方法的异常。(对于运行时异常则没有要求)

此外，**子类与父类中同名同参数的方法必须同时声明为非static的(即为重写)，或者同时声明为static的（不是重写）**。因为static方法是属于类的，子类无法覆盖父类的方法。


## 3. 关键字：super

### 3.1 super的理解

在Java类中使用super来调用父类中的指定操作：

- super可用于访问父类中定义的属性、成员方法
- super可用于在子类构造器中调用父类的构造器

注意：

- 尤其当子父类出现同名成员时，可以用super表明调用的是父类中的成员
- super的追溯不仅限于直接父类
- super和this的用法相像，**this代表本类对象的引用，super代表父类的内存空间的标识**

### 3.2 super的使用场景

#### 3.2.1 子类中调用父类被重写的方法

- 如果子类没有重写父类的方法，只要权限修饰符允许，在子类中完全可以直接调用父类的方法；
- 如果子类重写了父类的方法，在子类中需要通过`super.`才能调用父类被重写的方法，否则默认调用的子类重写的方法

总结：

* **方法前面没有super.和this.**
  * 先从子类找匹配方法，如果没有，再从直接父类找，再没有，继续往上追溯

* **方法前面有this.**
  * 先从子类找匹配方法，如果没有，再从直接父类找，再没有，继续往上追溯

* **方法前面有super.**
  * 从当前子类的直接父类找，如果没有，继续往上追溯

#### 3.2.2 子类中调用父类中同名的成员变量

- 如果实例变量与局部变量重名，可以在实例变量前面加this.进行区别
- 如果子类实例变量和父类实例变量重名，并且父类的该实例变量在子类仍然可见，在子类中要访问父类声明的实例变量需要在父类实例变量前加super.，否则默认访问的是子类自己声明的实例变量
- 如果父子类实例变量没有重名，只要权限修饰符允许，在子类中完全可以直接访问父类中声明的实例变量，也可以用this.实例访问，也可以用super.实例变量访问


总结：

* **变量前面没有super.和this.**
  * 在构造器、代码块、方法中如果出现使用某个变量，先查看是否是当前块声明的`局部变量`，
  * 如果不是局部变量，先从当前执行代码的`本类去找成员变量`
  * 如果从当前执行代码的本类中没有找到，会往上找`父类声明的成员变量`（权限修饰符允许在子类中访问的）

* **变量前面有this.** 
  * 通过this找成员变量时，先从当前执行代码的**本类去找成员变量**
  * 如果从当前执行代码的本类中没有找到，会往上找**父类声明的成员变量**（权限修饰符允许在子类中访问的）

* **变量前面super.** 
  * 通过super找成员变量，直接从当前执行代码的直接父类去找成员变量（权限修饰符允许在子类中访问的）
  * 如果直接父类没有，就去父类的父类中找（权限修饰符允许在子类中访问的）

**特别说明：应该避免子类声明和父类重名的成员变量**


#### 3.2.3 子类构造器中调用父类构造器

1. 子类继承父类时，不会继承父类的构造器。只能通过`super(形参列表)`的方式调用父类指定的构造器。

2. 规定：“super(形参列表)”，必须声明在构造器的首行。

3. 在构造器的首行，"this(形参列表)" 和 "super(形参列表)"只能二选一。

4. 如果在子类构造器的首行既没有显示调用"this(形参列表)"，也没有显式调用"super(形参列表)"，则子类此构造器默认调用"super()"，即调用父类中空参的构造器。

5. 由3和4得到结论：子类的任何一个构造器中，要么会调用本类中重载的构造器，要么会调用父类的构造器。只能是这两种情况之一。**因此我们在通过子类的构造器创建对象时，一定会先直接或间接地调用父类的构造器**，所以父类中声明的属性和方法也会加载到内存中。

6. 由5得到：一个类中声明有n个构造器，最多有n-1个构造器中使用了"this(形参列表)"，则剩下的那个一定使用"super(形参列表)"。

> 开发中常见错误：
>
> 如果子类构造器中既未显式调用父类或本类的构造器，且父类中又没有空参的构造器，则`编译出错`。

例题：

```java
public class Test {
    public static void main(String args[]) {
        Father f = new Father();
        Son s = new Son();
        System.out.println(f.getInfo()); // atguigu
        System.out.println(s.getInfo()); // atguigu
        s.test(); // atguigu atguigu
        System.out.println("------------");
        s.setInfo("大硅谷");
        System.out.println(f.getInfo()); // atguigu
        System.out.println(s.getInfo()); // 大硅谷
        s.test(); // 大硅谷 大硅谷
    }
}
class Father {
    private String info = "atguigu";
    public void setInfo(String info) {
        this.info = info;
    }
    public String getInfo() {
        return info;
    }
}
class Son extends Father{
    private String info = "尚硅谷";
    public void test() {
        System.out.println(this.getInfo());
        System.out.println(super.getInfo());
    }
}
```



## 4. 面向对象特征三：多态性

### 4.1 多态的形式和体现

#### 4.1.1 对象的多态性

多态性，是面向对象中最重要的概念，在Java中的体现：**对象的多态性：父类的引用指向子类的对象**

格式：（父类类型：指子类继承的父类类型，或者实现的接口类型）

```java
父类类型 变量名 = 子类对象；
```

举例：

```java
Person p = new Student();

Object o = new Person();//Object类型的变量o，指向Person类型的对象

o = new Student(); //Object类型的变量o，指向Student类型的对象
```

对象的多态：在Java中，子类的对象可以替代父类的对象使用。所以，一个引用类型变量可能指向(引用)多种不同类型的对象

#### 4.1.2 多态的理解

Java引用变量有两个类型：`编译时类型`和`运行时类型`。编译时类型由`声明`该变量时使用的类型决定，运行时类型由`实际赋给该变量的对象`决定。简称：**编译时，看左边；运行时，看右边。**

- 若编译时类型和运行时类型不一致，就出现了对象的多态性(Polymorphism)
- 多态情况下，“看左边”：看的是父类的引用（父类中不具备子类特有的属性和方法）；“看右边”：看的是子类的对象（实际运行的是子类重写父类的方法）

**多态的使用前提**：1.有继承/实现关系  2.方法的重写  3.存在父类引用子类对象

举例：
```java
class People {
    public String name = "People";
    public void run() {
        System.out.println("人可以跑");
    }
}
class Teacher extends People{
    public String name = "Teacher";
    @Override
    public void run() {
        System.out.println("老师跑的贼慢");
    }
}
class Student extends People {
    public String name = "Student";
    @Override
    public void run() {
        System.out.println("学生跑的贼快");
    }
}
public class Test {
    public static void main(String[] args) {
        // 对象多态
        // 编译看左边(p1和p2都是People类型，但指向的对象不一样)
        People p1 = new Teacher();
        People p2 = new Student();
        // 行为多态
        // 运行看右边(run方法行为不一样)
        p1.run(); // 老师跑的贼慢
        p2.run(); // 学生跑的贼快
        // 成员变量没有多态(多态只有对象多态、行为多态)
        System.out.println(p1.name); // People
        System.out.println(p2.name); // People
    }
}
```

**注意：成员变量没有多态性**

#### 4.1.3 多态的应用场景

**1、方法内局部变量的赋值体现多态**

```java
public class Test {
    public static void main(String[] args) {
        // 编译看左边父类，只能调用父类声明的方法
        // 运行看右边子类，如果子类重写了方法，一定是执行子类重写的方法体
        People p1 = new Teacher();
        p1.run(); // 老师跑的贼慢
    }
}
```

**2、方法的形参声明体现多态**

```java
public class Test {
    public static void main(String[] args) {
        Test test = new Test();
        //形参是父类类型，实参是子类对象
        //实际引用的对象类型不同，执行的run方法也不同
        test.peopleTest(new Teacher()); // People  老师跑的贼慢
    }
    public void peopleTest(People p) {
        System.out.println(p.name);
        p.run();
    }
}
```

**3、方法返回值类型体现多态**

```java
public class Test {
    public static void main(String[] args) {
        Test test = new Test();
        People t = test.peopleTest("Teacher");
        t.run(); // 老师跑的贼慢
        System.out.println(t.name); // People
        People s = test.peopleTest("Student");
        s.run(); // 学生跑的贼快
        System.out.println(s.name); // People
    }
    //返回值类型是父类类型，实际返回的是子类对象
    public People peopleTest(String type) {
        switch (type) {
            case "Teacher" :
                return new Teacher();
            default:
                return new Student();
        }
    }
}
```

### 4.2 多态的好处和弊端

**好处**：变量引用的子类对象不同，执行的方法就不同，实现动态绑定。代码编写更灵活、功能更强大，可维护性和扩展性更好了。比如，在多态形式下，上述代码中`new Teacher()`是解耦合的，更便于扩展和维护，即刚开始p1指向Teacher对象，run方法执行的就是Teacher对象的业务；假如p1指向Student对象，run方法执行的自然是Student对象的业务。

**弊端**：一个引用类型变量如果声明为父类的类型，但实际引用的是子类对象，那么该变量就不能再访问子类中添加的属性和方法。

> 开发中：
>
> 使用父类做方法的形参，是多态使用最多的场合。即使增加了新的子类，方法也无需改变，提高了扩展性，符合开闭原则。
>
> 【开闭原则OCP】
>
> - 对扩展开放，对修改关闭
> - 通俗解释：软件系统中的各种组件，如模块（Modules）、类（Classes）以及功能（Functions）等，应该在不修改现有代码的基础上，引入新功能

### 4.3 虚方法调用(Virtual Method Invocation)

在Java中虚方法是指在编译阶段不能确定方法的调用入口地址，在运行阶段才能确定的方法，即可能被重写的方法。

```java
People s = new Student();
s.run(); //调用Student类的run()方法
```

子类中定义了与父类同名同参数的方法，在多态情况下，将此时父类的方法称为虚方法，父类根据赋给它的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译期是无法确定的。


> 拓展：
>
> `静态链接（或早起绑定）`：当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期可知，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。那么调用这样的方法，就称为非虚方法调用。比如调用静态方法、私有方法、final方法、父类构造器、本类重载构造器等。
>
> `动态链接（或晚期绑定）`：如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。调用这样的方法，就称为虚方法调用。比如调用重写的方法（针对父类）、实现的方法（针对接口）。

### 4.4 向上转型与向下转型

首先，一个对象在new的时候创建是哪个类型的对象，它从头至尾都不会变。即这个对象的运行时类型，本质的类型永远不会变。但是，把这个对象赋值给不同类型的变量时，这些变量的编译时类型却不同。

#### 4.4.1 为什么要类型转换

因为多态，就一定会有把子类对象赋值给父类变量的时候，这个时候，在`编译期间`，就会出现类型转换的现象。

但是，使用父类变量接收了子类对象之后，我们就`不能调用`子类拥有、而父类没有的方法了。这也是多态给我们带来的一点"小麻烦"。所以，想要调用子类特有的方法，必须做类型转换，使得`编译通过`。


* **向上转型**：当左边的变量的类型（父类） > 右边对象/变量的类型（子类），我们就称为向上转型
  * 此时，编译时按照左边变量的类型处理，就只能调用父类中有的变量和方法，不能调用子类特有的变量和方法了
  * 但是，**运行时，仍然是对象本身的类型**，所以执行的方法是子类重写的方法体。
  * 此时，一定是安全的，而且也是自动完成的

* **向下转型**：当左边的变量的类型（子类）<右边对象/变量的编译时类型（父类），我们就称为向下转型
  * 此时，编译时按照左边变量的类型处理，就可以调用子类特有的变量和方法了
  * 但是，**运行时，仍然是对象本身的类型**
  * 不是所有通过编译的向下转型都是正确的，可能会发生ClassCastException，为了安全，可以通过isInstanceof关键字进行判断

#### 4.4.2 如何向上或向下转型

向上转型：自动完成

向下转型：（子类类型）父类变量

```java
public class ClassCastTest {
    public static void main(String[] args) {
        //向上转型
        Pet pet = new Dog();//pet的编译时类型是Pet，运行时类型是Dog
        pet.eat();//可以调用父类Pet有声明的方法eat，但执行的是子类重写的eat方法体
//      pet.watchHouse();//不能调用父类没有的方法watchHouse
        if (d instanceof Dog) {
            Dog d = (Dog) pet;
            d.watchHouse();//可以调用子类扩展的方法watchHouse
        }
        
        Cat c = (Cat) pet;
        //编译通过，因为从语法检查来说，pet的编译时类型是Pet，Cat是Pet的子类，所以向下转型语法正确
        //这句代码运行报错ClassCastException，因为pet变量的运行时类型是Dog，Dog和Cat之间是没有继承关系的
    }
}
```

#### 4.4.3 instanceof关键字

为了避免ClassCastException的发生，Java提供了 `instanceof` 关键字，给引用变量做类型的校验。如下代码格式：

```java
//检验对象a是否是类A的对象，返回值为boolean型
对象a instanceof 类A 
```

**说明**：
- 只要用instanceof判断返回true的，那么强转为该类型就一定是安全的，不会报ClassCastException异常。
- 如果对象a属于类A的子类B，a instanceof A值也为true。
- 使用instanceof时，要求对象a所属的类与类A必须是子类和父类的关系(或者相同类)，否则编译错误。

### 4.5 经典例题

**练习1：**

```java
class Base {
    int count = 10;
    public void display() {
        System.out.println(this.count);
    }
}

class Sub extends Base {
    int count = 20;
    public void display() {
        System.out.println(this.count);
    }
}

public class Test {
    public static void main(String[] args){
        Sub s = new Sub();
        System.out.println(s.count); // 20
        s.display(); // 20
        Base b = s;
        System.out.println(b == s); // true
        System.out.println(b.count); // 10
        b.display(); // 20
    }
}
```

**练习2-1：**

```java
public class Test {
    public static void main(String[] args) {
        Base base = new Sub();
        base.add(1, 2, 3); // sub_1
    }
}
class Base {
    public void add(int a, int ... arr) {
        System.out.println("base");
    }
}
class Sub extends Base {
    public void add(int a, int[] arr) {
        System.out.println("sub_1");
    }
}
```

**解释：数组与可变参数是冲突的，所以子类的add方法是重写了父类的add方法，因此由多态性调用子类的add方法，所以输出sub_1**

**练习2-2：**

```java
public class Test {
    public static void main(String[] args) {
        Base base = new Sub();
        base.add(1, 2, 3); // sub_1
    }
}
class Base {
    public void add(int a, int... arr) {
        System.out.println("base");
    }
}
class Sub extends Base {
    public void add(int a, int[] arr) {
        System.out.println("sub_1");
    }
    public void add(int a, int b, int c) {
		System.out.println("sub_2");
	}
}
```

**解释：注意子类的三参数的add方法只是与父类的add方法构成重载，并不是重写。而子类的第一个add方法是重写(覆盖)了父类的add方法，因此由多态性调用子类重写的add方法，所以输出sub_1**


**练习2-3：**

```java
public class Test {
    public static void main(String[] args) {
        Base base = new Sub();
        base.add(1, 2, 3); // sub_1
        
        Sub s = (Sub)base;
        s.add(1,2,3); // sub_2
    }
}
class Base {
    public void add(int a, int... arr) {
        System.out.println("base");
    }
}
class Sub extends Base {
    public void add(int a, int[] arr) {
        System.out.println("sub_1");
    }
    public void add(int a, int b, int c) {
		System.out.println("sub_2");
	}
}
```

**解释：对于 `s.add(1,2,3);`，此时没有发生多态，于是子类直接调用自己的三参数add方法**。



## 5. Object类的使用

### 5.1 如何理解根父类

类 `java.lang.Object`是类层次结构的根类，即所有其它类的父类。每个类都使用 `Object` 作为超类。

* Object类型的变量与除Object以外的任意引用数据类型的对象都存在多态引用

  ```java
  method(Object obj){…} //可以接收任何类作为其参数
  
  Person o = new Person();  
  method(o);
  
  ```

* 所有对象（包括数组）都实现这个类的方法。
* 如果一个类没有特别指定父类，那么默认则继承自Object类。
* Object类中没有声明属性。Object类提供一个无参构造器。

### 5.2 Object类的方法

根据JDK源代码及Object类的API文档，Object类当中包含的方法有11个。这里我们主要关注其中的6个：

#### 1、equals()

```java
public boolean equals(Object obj)
```

自定义的类在没有重写Object中equals()方法的情况下，调用的就是Object类中声明的equals()，其底层实现其实就是`return this == obj;`，即比较两个对象的引用地址是否相同。注意用`==`进行比较时，符号两边的数据类型必须兼容(可自动转换的基本数据类型除外)，否则编译出错。所以两个不兼容类的对象，直接用 `==` 判断会编译出错，调用 `equals()` 方法则不会编译出错，而会返回false。

**注意**：当用equals()方法进行比较时，对类File、String、Date及包装类（Wrapper Class）来说，是比较类型及内容而不考虑引用的是否是同一个对象。原因就是在这些类中重写了Object类的equals()方法。

因此，直接比较两个同类对象的地址是否相同完全可以用 `==` 替代 `equals`，`equals` 存在的意义就是为了被子类重写，以便子类自己来定制比较规则（比如比较对象内容）。

```java
public class Student{
    private String name;
    private int age;
    
    public Student(String name, int age){
        this.name=name;
        this.age=age;
    }
    
    @Override
    public String toString(){
        return "Student{name=‘"+name+"’, age="+age+"}";
    }
    
    //重写equals方法，按照对象的属性值进行比较
    @Override
    public boolean equals(Object o) {
        // 如果地址相同，直接返回true
        if (this == o) return true;
        // 如果o是null，返回false
        // 如果两个对象的类型class不同，返回false
        if (o == null || getClass() != o.getClass()) return false;
        
        Student student = (Student) o;
        // 比较两个对象的内容
        return age == student.age && Objects.equals(name, student.name);
    }
}
```

**练习：**

```java
int it = 65;
float fl = 65.0f;
System.out.println("65和65.0f是否相等？" + (it == fl)); // true

char ch1 = 'A'; char ch2 = 12;
System.out.println("65和'A'是否相等？" + (it == ch1));// true
System.out.println("12和ch2是否相等？" + (12 == ch2));// true

String str1 = new String("hello");
String str2 = new String("hello");
System.out.println("str1和str2是否相等？"+ (str1 == str2));// false

System.out.println("str1是否equals str2？"+(str1.equals(str2)));// true
```

#### 2、toString()

```java
public String toString() {
        return getClass().getName() + "@" + Integer.toHexString(hashCode());
}
// 调用toString()方法可以返回对象的字符串表示形式
// 默认的格式是：“包名.对象的运行时类型@哈希值16进制”
```

**注1**：我们根据`println`的底层实现可以发现，如果 `s` 是引用类型，则 `System.out.println(s);` 等价于 `System.out.println(s.toString());`

> 因为Java的引用数据类型的变量中存储的实际上时对象的内存地址，但是Java对程序员隐藏内存地址信息，所以不能直接将内存地址显示出来，所以当你打印对象时，JVM帮你调用了对象的toString()。

**注2**：在进行String与其它类型数据的连接操作时，会自动调用toString()方法

```java
Date now = new Date();
System.out.println("now=" + now);  //相当于
System.out.println("now=" + now.toString()); 
```

**注3**：可以根据需要在用户自定义类型中重写toString()方法。如 String 类重写了toString()方法，返回字符串的值。

```java
public class Student{
    private String name;
    private int age;

    public Student() {
    }

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}
```

#### 3、clone()

Object类的clone()方法：当某个对象调用这个方法时，这个方法会复制一个一模一样的新对象返回。

```java
// 克隆当前对象，返回一个新对象
protected Object clone()
```

- 想要调用clone()方法，必须让被克隆的类实现Cloneable接口(Cloneable只是一个标记接口，里面没有内容，代表一种规则)。
- 必须重写clone()方法

```java
public class User implements Cloneable{
    private int id;
    private String name;
    private double[] scores;

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}
public class Test {
    public static void main(String[] args) throws CloneNotSupportedException {
        User u1 = new User();
        User u2 = (User) u1.clone();
    }
}
```

上面演示的克隆方式，是一种浅克隆的方法，浅克隆的意思：**拷贝出的新对象，与原对象中的数据一模一样（引用类型的属性，拷贝的只是地址）**。

还有一种拷贝方式，称之为深克隆：**对象中基本类型的数据直接拷贝；对象中的字符串数据拷贝的还是地址；对象中还包含的其他对象，不会拷贝地址，会创建新对象**。

重写一下 `clone` 即可实现深克隆。

```java
    protected Object clone() throws CloneNotSupportedException {
        // 先克隆得到一个新对象
        User u = (User) super.clone();
        // 再将新对象中的引用类型数据，再次克隆
        u.scores = u.scores.clone();
        return u;
    }
```


#### 4、finalize()

- 当对象被回收时，系统自动调用该对象的 finalize() 方法。（不是垃圾回收器调用的，是本类对象调用的）。注意永远不要主动调用某个对象的finalize方法，应该交给垃圾回收机制调用。
- 子类可以重写该方法，目的是在对象被清理之前执行必要的清理操作。比如，在方法内断开相关连接资源。
- 在JDK 9中此方法已经被`标记为过时`的。



#### 5、getClass()

`public final Class<?> getClass()`：获取对象的运行时类型

> 因为Java有多态现象，所以一个引用数据类型的变量的编译时类型与运行时类型可能不一致，因此如果需要查看这个变量实际指向的对象的类型，需要用getClass()方法

```java
public static void main(String[] args) {
	Object obj = new Person();
	System.out.println(obj.getClass());//运行时类型
}
```

结果：

```java
class com.atguigu.java.Person
```

#### 6、hashCode()

`public int hashCode()`：返回每个对象的hash值。

```java
public static void main(String[] args) {
	System.out.println("AA".hashCode());//2080
    System.out.println("BB".hashCode());//2112
}
```

### 5.3 native关键字的理解

使用native关键字说明这个方法是原生函数，也就是这个方法是用`C/C++`等非Java语言实现的，并且`被编译成了DLL`，由Java去调用。

- 本地方法是有方法体的，用c语言编写。由于本地方法的方法体源码没有对我们开源，所以我们看不到方法体

- 在Java中定义一个native方法时，并不提供实现体。

**1. 为什么要用native方法**

Java使用起来非常方便，然而有些层次的任务用java实现起来不容易，或者我们对程序的效率很在意时，例如：Java需要与一些底层操作系统或某些硬件交换信息时的情况。native方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。

**2. native声明的方法，对于调用者，可以当做和其他Java方法一样使用**

native method的存在并不会对其他类调用这些本地方法产生任何影响，实际上调用这些方法的其他类甚至不知道它所调用的是一个本地方法。JVM将控制调用本地方法的所有细节。



# 第08章_面向对象编程(高级)

## 1. 关键字：static

### 1.1 static关键字

**使用范围**：
- 在Java类中，可用static修饰属性、方法、代码块、内部类

**被修饰后的成员具备以下特点**：
- 随着类的加载而加载
- 优先于对象存在
- 修饰的成员，被所有对象所共享
- 访问权限允许时，可不创建对象，直接被类调用

### 1.2 静态变量

Java中的成员变量按照有无static修饰分为两种：**类变量、实例变量**。它们的区别如下图所示：

- 类变量(静态变量)：有static修饰，属于类，在计算机里只有一份，会被类的全部对象共享。**随着类的加载，静态变量会被加载到堆内存中的静态域中**，其默认初始值与实例变量的默认初始值规则相同。
- 实例变量：无static修饰，属于每个对象。

由于静态变量是属于类的，只需要通过类名就可以调用：**`类名.静态变量`** (虽然 `对象.静态变量` 也能访问静态变量，但并不推荐这么调用)

实例变量是属于对象的，需要通过对象才能调用：**`对象.实例变量`**

![](/zzimages/1663978808670.png)


### 1.3 静态方法

成员方法根据有无static也分为两类：**类方法、实例方法**

- 有static修饰的方法，是属于类的，称为**类方法(静态方法)**；调用时直接用类名调用即可。(不推荐使用对象来调用类方法)。

- 无static修饰的方法，是属于对象的，称为实例方法；调用时，需要使用对象调用。

**静态方法的特点**：

1. 在static方法内部只能访问类的static修饰的属性或方法，不能访问类的非static的结构。而实例方法中既可以直接访问static结构，也可以直接访问非static结构。
2. 静态方法可以被子类继承，但不能被子类重写。
3. 静态方法的调用都只看编译时类型。
4. 因为不需要实例就可以访问static方法，因此static方法内部不能有this，也不能有super。如果有重名问题，使用“类名.”进行区别。

![](/zzimages/1664005554987.png)


练习：
```java
// 以下代码不会有空指针异常，因为是静态变量和方法
public class StaticTest {
    public static void main(String[] args) {
        Demo test = null;
        test.hello(); // hello!
        System.out.println(test.count); // 1
    }
}
class Demo{
    public static int count = 1;
    public static void hello(){
        System.out.println("hello!");
    }
}
```

### 1.4 工具类

如果一个类中的方法全都是静态的，那么这个类中的方法就全都可以被类名直接调用，由于调用起来非常方便，就像一个工具一样，所以把这样的类就叫做工具类。

> 再补充一点，工具类里的方法全都是静态的，所以应该用类名调用。为了防止使用者用对象调用，我们可以把工具类的构造方法私有化。

```java
public class MyUtils{
    //私有化构造方法：这样别人就不能使用构造方法new对象了
    private MyUtils(){
        
    }
    
    //类方法
    public static String createCode(int n){
       ...
    }
}
```


## 2. 单例(Singleton)设计模式

### 2.1 设计模式概述

**设计模式**是在大量的`实践中总结`和`理论化`之后优选的代码结构、编程风格、以及解决问题的思考方式。设计模式免去我们自己再思考和摸索。就像是经典的棋谱，不同的棋局，我们用不同的棋谱。

经典的设计模式共有23种。每个设计模式均是特定环境下特定问题的处理方法。

![](/zzimages/20220520174508815.png)

> 简单工厂模式并不是23中经典模式的一种，是其中工厂方法模式的简化版。对软件设计模式的研究造就了一本可能是面向对象设计方面最有影响的书籍：《设计模式》

### 2.2 单例模式

所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类**只能存在一个对象实例**，并且该类只提供一个取得其对象实例的方法。

### 2.3 实现思路

如果我们要让类在一个虚拟机中只能产生一个对象，我们首先必须将`类的构造器的访问权限设置为private`，这样，就不能用new操作符在类的外部产生类的对象了，但在类内部仍可以产生该类的对象。因为在类的外部开始还无法得到类的对象，`只能调用该类的某个静态方法`以返回类内部创建的对象，静态方法只能访问类中的静态成员变量，所以，指向类内部产生的`该类对象的变量也必须定义成静态的`。

### 2.4 单例模式的两种实现方式

#### 2.4.1 饿汉式

```java
class Singleton {
    // 1.私有化构造器
    private Singleton() {
    }

    // 2.内部提供一个当前类的实例
    // 4.此实例也必须静态化
    private static Singleton single = new Singleton();

    // 3.提供公共的静态的方法，返回当前类的对象
    public static Singleton getInstance() {
        return single;
    }
}
```

#### 2.4.2 懒汉式

```java
class Singleton {
    // 1.私有化构造器
    private Singleton() {
    }
    // 2.内部提供一个当前类的实例
    // 4.此实例也必须静态化
    private static Singleton single;
    // 3.提供公共的静态的方法，返回当前类的对象
    public static Singleton getInstance() {
        if (single == null) {
            single = new Singleton();
        }
        return single;
    }
}
```

#### 2.4.3 饿汉式 vs 懒汉式

饿汉式：

- 特点：`立即加载`，即在使用类的时候已经将对象创建完毕。
- 优点：实现起来`简单`；没有多线程安全问题。
- 缺点：当类被加载的时候，会初始化static的实例，静态变量被创建并分配内存空间，从这以后，这个static的实例便一直占着这块内存，直到类被卸载时，静态变量被摧毁，并释放所占有的内存。因此在某些特定条件下会`耗费内存`。

懒汉式：

- 特点：`延迟加载`，即在调用静态方法时实例才被创建。
- 优点：实现起来比较简单；当类被加载的时候，static的实例未被创建并分配内存空间，当静态方法第一次被调用时，初始化实例变量，并分配内存，因此在某些特定条件下会`节约内存`。
- 缺点：在多线程环境中，这种实现方法是完全错误的，`线程不安全`，根本不能保证单例的唯一性。
  - 说明：在多线程章节，会将懒汉式改造成线程安全的模式。

### 2.5 单例模式的优点及应用场景

由于单例模式只生成一个实例，减少了`系统性能开销`，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决。


**应用场景**

- Windows的Task Manager(任务管理器)就是很典型的单例模式
- Windows的Recycle Bin (回收站)也是典型的单例应用。在整个系统运行过程中，回收站一直维护着仅有的一个实例。
- Application 也是单例的典型应用
- 应用程序的日志应用，一般都使用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加。
- 数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。

## 3. 理解main方法的语法

由于JVM需要调用类的main()方法，所以该方法的访问权限必须是public，又因为JVM在执行main()方法时不必创建对象，所以该方法必须是static的，该方法接收一个String类型的数组参数，该数组中保存执行Java命令时传递给所运行的类的参数。 

又因为main() 方法是静态的，我们不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员，这种情况，我们在之前的例子中多次碰到。

**main()方法有两种理解**：

1. 看作是程序的入口，格式是固定的
2. 看作是一个普通的静态方法

```java
public class Test {
    public static void main(String[] args) {
        String[] arr = {"aaa", "bbb", "ccc"};
        Main.main(arr);
    }
}
class Main{
    // 看作是普通的静态方法
    public static void main(String[] args) {
        System.out.println("Main的静态方法main()调用了");
        for (int i = 0; i < args.length; i++)
            System.out.println(args[i]);
    }
}
```

如果我们从Main的main()方法处运行程序，事实上就相当于Java调用了 `Main.main()`，于是会输出：

```
Main的静态方法main()调用了
```

如果我们从Test的main()方法处运行程序，则Java调用了 `Test.main()`，而其中的 `Main.main()` 调用就只被视作为一个普通的静态方法调用，此时会输出：

```
Main的静态方法main()调用了
aaa
bbb
ccc
```

**命令行参数用法举例**

**1、直接在命令行窗口运行程序并传入参数**

```java
public class CommandPara {
    public static void main(String[] args) {
        for (int i = 0; i < args.length; i++) {
            System.out.println("args[" + i + "] = " + args[i]);
        }
    }
}
```

```java
//运行程序
java CommandPara "Tom" "Jerry" "Shkstart"
```

```java
//输出结果
args[0] = Tom
args[1] = Jerry
args[2] = Shkstart
```

**2、在IDEA中设置命令行参数**

打开 `Run -> Edit Configurations` 然后配置命令行参数

![](/zzimages/20211228102022216.png)



## 4. 类的成员之四：代码块

代码块（也称为初始化块）的作用：用来初始化类或对象的成员变量。代码的修饰符只能是 static 或 缺省。

### 4.1 静态代码块

#### 4.1.1 语法格式

在代码块的前面加static，就是静态代码块。

```java
[修饰符] class 类{
	static{
        静态代码块
    }
}
```

#### 4.1.2 静态代码块的特点

1. 随着类的加载而执行。由于类的加载只会执行一次，进而静态代码块也只会执行一次
2. 静态代码块的执行要先于非静态代码块的执行
3. 静态代码块内部**只能调用静态的结构**（即静态的属性、方法）
4. 如果声明多个静态代码块，则按照声明的先后顺序执行


### 4.2 非静态代码块

#### 4.2.1 语法格式

```java
[修饰符] class 类{
    {
        非静态代码块
    }
}
```

#### 4.2.2 非静态代码块的执行特点

1. 随着对象的创建而执行，且先于构造器而执行。每创建当前类的一个实例，就会执行一次非静态代码块。
2. 非静态代码块内部可以调用静态的结构（即静态的属性、方法），也可以调用非静态的结构
3. 如果声明多个非静态代码块，则按照声明的先后顺序执行



### 4.3 小结：实例变量赋值顺序

第一优先级：声明成员变量的默认初始化

第二优先级：显式初始化、多个初始化块依次执行。(同级别下按声明的先后顺序执行，例如，显式初始化语句在初始化块之后，则会先执行代码块，然后再进行显式初始化赋值)

第三优先级：构造器再对成员进行初始化操作

第四优先级：通过 `对象.属性` 或 `对象.方法` 的方法，可多次给属性赋值

**补充知识**：关于字节码文件中的`<init>`的简单说明

- `<init>`方法在字节码文件中可以看到，每个`<init>`方法都对应着一个类的构造器。
- 编写的代码中的构造器在编译以后就会以`<init>`方法的方式呈现。
- `<init>`方法内部的代码包含了实例变量的显式赋值、代码块中的赋值和构造器中的代码。
- `<init>`方法是用来初始化当前创建的对象的信息的。


**练习1:**

```java
class Root{
    static{
        System.out.println("Root的静态初始化块");
    }
    {
        System.out.println("Root的普通初始化块");
    }
    public Root(){
        System.out.println("Root的无参数的构造器");
    }
}
class Mid extends Root{
    static{
        System.out.println("Mid的静态初始化块");
    }
    {
        System.out.println("Mid的普通初始化块");
    }
    public Mid(){
        System.out.println("Mid的无参数的构造器");
    }
    public Mid(String msg){
        //通过this调用同一类中重载的构造器
        this();
        System.out.println("Mid的带参数构造器，其参数值："
                + msg);
    }
}
class Leaf extends Mid{
    static{
        System.out.println("Leaf的静态初始化块");
    }
    {
        System.out.println("Leaf的普通初始化块");
    }
    public Leaf(){
        //通过super调用父类中有一个字符串参数的构造器
        super("尚硅谷");
        System.out.println("Leaf的构造器");
    }
}
public class Test{
    public static void main(String[] args){
        new Leaf();
        // Root的静态初始化块
        // Mid的静态初始化块
        // Leaf的静态初始化块
        // Root的普通初始化块
        // Root的无参数的构造器
        // Mid的普通初始化块
        // Mid的无参数的构造器
        // Mid的带参数构造器，其参数值：尚硅谷
        // Leaf的普通初始化块
        // Leaf的构造器
    }
}
```

**解释：类加载时先加载父类，简而言之，由父及子、静态先行**。


**练习2**：

```java
class Base {
    Base() {
        method(100);
    }
    {
        System.out.println("base");
    }
    public void method(int i) {
        System.out.println("base:" + i);
    }
}
class Sub extends Base {
    Sub() {
        super.method(70);
    }
    {
        System.out.println("sub");
    }
    public void method(int j) {
        System.out.println("sub:" + j);
    }
}
public class Test {
    public static void main(String[] args) {
        Sub s = new Sub();
        // base
        // sub:100
        // sub
        // base:70
    }
}
```

**解释：第二行输出`sub:100`的原因是子类重写(覆盖)了method方法，由多态性会调用子类的method**



## 5. final关键字

### 5.1 final的意义

final：最终的，不可更改的

final可以用来修饰的结构：类、方法、变量

### 5.2 final的使用

#### 5.2.1 final修饰类

final修饰类：表示这个类不能被继承，没有子类。例如：String类、System类、StringBuffer类、StringBuilder类等。

#### 5.2.2 final修饰方法

final修饰方法：表示这个方法不能被子类重写。比如：Object类中的getClass()

#### 5.2.3 final修饰变量

final修饰某个变量（成员变量或局部变量），一旦赋值，它的值就不能被修改，即常量，常量建议名称全部大写，多个单词用下划线连接。

**final修饰成员变量**：可以显式赋值、或在代码块中赋值、实例变量还可以在构造器中赋值。一旦赋值，它的值就不能被修改。

```java
public final class Test {
    public static int totalNumber = 5;
    public final int ID;

    public Test() {
        ID = 1; // 可在构造器中给final修饰的实例变量赋值
    }
    public Test(int num) {
        ID = num; // 可在构造器中给final修饰的实例变量赋值
    }

    public static void main(String[] args) {
        Test t1 = new Test();
        System.out.println(t1.ID);
        Test t2 = new Test(100);
        System.out.println(t2.ID);
    }
}
```

**final修饰局部变量**：一旦赋值，它的值就不能被修改。

- 对于方法内声明的局部变量，在调用局部变量前，一定需要赋值。
- 对于方法的形参，在调用此方法时，就会给形参进行赋值。所以方法内不能再对它进行赋值。

```java
    public void func(final int arg) {
        //arg = 0; // 报错

        final int tmp;
        tmp = 1;
        //tmp++; // 报错

        final int[] arr = {10, 20, 30};
        arr[0] = 666; // 正确，因为引用类型的变量存储的是地址值，只要地址值不被修改即可
        //arr = null; // 报错
    }
```

**全局常量**：被 `static final` 修饰的成员变量，称之为全局常量。通常都用以下格式声明：

```java
public static final String COUNTRY_NAME = "中国";
```

全局常量通常用于记录系统的配置信息，使代码可读性更好，可维护性也更好，而且性能也很好，因为程序编译后，全局常量会被“宏替换”：出现全局常量的地方全部会被替换成其记住的字面量，这样可以保证使用全局常量和直接用字面量的性能是一样的。



## 6. 抽象类与抽象方法(或abstract关键字)

### 6.1 语法格式

在Java中有一个关键字叫abstract，它就是抽象的意思，它可以修饰类也可以修饰成员方法。

* **抽象类**：被abstract修饰的类。
* **抽象方法**：被abstract修饰的方法（不允许有方法体，只能有方法签名）。

抽象类的语法格式：

```java
[权限修饰符] abstract class 类名{
    
}
[权限修饰符] abstract class 类名 extends 父类{
    
}
```

抽象方法的语法格式：

```java
[其他修饰符] abstract 返回值类型 方法名([形参列表]);
```

**抽象的好处**：父类知道每个子类都要做某个行为，但每个子类要做的情况不一样，父类就定义成抽象方法，交给子类去重写实现，我们设计这样的抽象类，**就是为了更好地支持多态**。

示例：
```java
abstract class Animal {
    private String name;
    public abstract void cry();
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
}
class Cat extends Animal{
    @Override
    public void cry() {
        System.out.println(getName() + "cat cry");
    }
}
class Dog extends Animal{
    @Override
    public void cry() {
        System.out.println(getName() + "dog cry");
    }
}
public class Test {
    public static void main(String[] args) {
        // 抽象类本身不能创建对象，但是可以声明引用，去引用其非抽象子类创建的对象
        Animal a = new Dog();
        a.setName("二花");
        a.cry(); // 二花dog cry
    }
}
```

### 6.2 使用说明

1. 抽象类**不能创建对象**，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。

   > 理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。因此，抽象类是用来被继承的。

2. 抽象类中，也有构造方法，是供子类创建对象时，初始化父类成员变量使用的。类该有的成员（成员变量、方法、构造器）抽象类都可以有。

   > 理解：子类的构造方法中，有默认的super()或手动的super(实参列表)，需要访问父类构造方法。

3. 抽象类中可以没有抽象方法。但是，有抽象方法的类，必须是抽象类。

   > 理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。

4. 抽象类的子类，必须重写抽象父类中**所有的**抽象方法，否则，编译无法通过而报错，除非该子类也是抽象类。注意：子类对抽象方法的重写，实际上就是在实现抽象方法，因此这种重写方法的操作，也可以称作**实现方法**。

   > 理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。

**注意**：

- 不能用abstract修饰变量、代码块、构造器；

- 不能用abstract修饰私有方法、静态方法、final的方法、final的类。
  > 理解：
  > 1.私有方法不能重写
  > 2.避免静态方法使用类进行调用
  > 3.final的方法不能被重写
  > 4.final修饰的类不能有子类



### 6.3 模板方法设计模式(TemplateMethod)

抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式。

**解决的问题**：

- 当功能内部一部分实现是确定的，另一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。

- 换句话说，在软件开发中实现一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了。但是某些部分易变，易变部分可以抽象出来，供不同子类实现。这就是一种模板模式。

**步骤**：
- 第1步：定义一个抽象类，把子类中相同的代码写成一个模板方法，建议使用final关键字修饰模板方法。
- 第2步：把模板方法中不能确定的代码写成抽象方法，并在模板方法中调用。
- 第3步：子类继承抽象类，只需要重写父类抽象方法就可以了。

```java
abstract class C {
    // 模板方法
    public final void sing() {
        System.out.println("唱一首歌");
        doSing();
        System.out.println("唱完了");
    }
    // 抽象方法
    public abstract void doSing();
}
class A extends C{
    @Override
    public void doSing() {
        System.out.println("歌名：AAA");
    }
}
class B extends C{
    @Override
    public void doSing() {
        System.out.println("歌名：BBB");
    }
}
public class Test {
    public static void main(String[] args) {
        B b = new B();
        b.sing();
    }
}
```


模板方法设计模式是编程中经常用得到的模式。各个框架、类库中都有他的影子，比如常见的有：

- 数据库访问的封装

- Junit单元测试

- JavaWeb的Servlet中关于doGet/doPost方法调用

- Hibernate中模板程序

- Spring中JDBCTemlate、HibernateTemplate等


## 7. 接口(interface)

### 7.1 定义格式

接口就是规范，定义的是一组规则。继承是一个"是不是"的is-a关系，而接口实现则是"能不能"的`has-a`关系。

接口的定义，与定义类方式相似，但是使用 `interface` 关键字。它也会被编译成.class文件，但一定要明确它并不是类，而是另外一种引用数据类型。

> 引用数据类型：数组，类，枚举，接口，注解。

#### 7.1.1 接口的声明格式

```java
[修饰符] interface 接口名{

}
```

#### 7.1.2 接口的成员说明

**在JDK8.0 之前**，接口中只允许出现：

（1）公共的静态的常量：其中`public static final`可以省略

（2）公共的抽象的方法：其中`public abstract`可以省略

> 理解：接口是从多个相似类中抽象出来的规范，不需要提供具体实现

**在JDK8.0 时**，接口中允许声明`默认方法`和`静态方法`：

（3）公共的默认的方法：其中public 可以省略，建议保留，但是default不能省略。建议格式 `public default`

（4）公共的静态的方法：其中public 可以省略，建议保留，但是static不能省略。建议格式 `public static`

**在JDK9.0 时**，接口又增加了：

（5）私有方法。必须用 `private` 修饰


### 7.2 接口的使用规则

**1、类实现接口（implements）**

接口**不能创建对象**，但是可以被类实现（`implements`）。

类与接口的关系为实现关系，即**类实现接口**，该类可以称为接口的实现类。实现的动作类似继承，格式相仿，只是关键字不同，实现使用`implements`关键字。

```java
【修饰符】 class 实现类 extends 父类 implements 接口1, 接口2 {
    // 重写接口中抽象方法【必须】，当然如果实现类是抽象类，那么可以不重写
  	// 重写接口中默认方法【可选】
}
```

**注意**：如果接口的实现类是非抽象类，那么必须`重写接口中所有抽象方法`。


**2、接口的多实现（implements）**

之前学过，在继承体系中，一个类只能继承一个父类。而对于接口而言，一个类是可以实现多个接口的，这叫做接口的`多实现`。所以，一个类能继承一个父类，同时实现多个接口，从而一定程度上就弥补了类的单继承的局限性。

> 接口中，有多个抽象方法时，实现类如果不声明为抽象类，则必须重写所有抽象方法。**如果抽象方法有重名的，只需要重写一次**。


**3、接口的多继承(extends)**

一个接口能继承另一个或者多个接口，接口的继承也使用 `extends` 关键字，子接口继承父接口的方法。例如

```java
interface A {}
interface B {}
interface C extends A, B {}
```

注意：如上代码，非抽象的实现类实现 `C` 接口时，必须把其父接口 `A 和 B` 的全部抽象方法也同样要重写。方法签名相同的抽象方法只需要实现一次。


**4、接口与实现类对象构成多态引用**

实现类实现接口，类似于子类继承父类，因此，接口类型的变量与实现类的对象之间，也可以构成多态引用。通过接口类型的变量调用方法，最终执行的是你new的实现类对象实现的方法体。

一般格式：
```java
接口名 变量名 = new 实现类();
```

```java
public class Test {
    public static void main(String[] args) {
        People people = new People();
        // 1. 创建接口实现类的对象
        Run run = new Run();
        people.say(run);
        // 2. 创建接口实现类的匿名对象
        people.say(new Run());
        // 3. 创建接口匿名实现类的对象
        Property p = new Property() {
            @Override
            public void show() {
                System.out.println("我还会游泳");
            }
        };
        people.say(p);
        // 4. 创建接口匿名实现类的匿名对象
        people.say(new Property() {
            @Override
            public void show() {
                System.out.println("我还会飞");
            }
        });
    }
}
class People {
    public void say(Property prop) { // 多态：Property prop = new Run();
        prop.show();
        System.out.println("---------------");
    }
}
interface Property {
    void show();
}
class Run implements Property {
    @Override
    public void show() {
        System.out.println("我会跑步");
    }
}
```

注意：如果类A继承了类B，并实现了接口C，则创建 `B obj = new A();` 后，`obj` 无法直接调用 `A` 中实现的接口方法，因为编译时类型是 `B`。此时我们仍然可以用 `obj instanceof C` 来判断 `obj` 是否是接口类型或其实现类，然后返回true，就可以强制类型转换 `C tmp = (C) obj;` ，然后调用独有的接口方法。


**5、使用接口的静态成员**

接口不能直接创建对象，但是**可以通过接口名直接调用接口的静态方法和静态常量**。

**注意**：
- 接口的静态常量还可以被其实现类调用
- 但是接口的静态方法无法被实现类调用(因为接口中的静态方法不能被继承也不能被重写)。

```java
public class Test {
    public static void main(String[] args) {
        //通过“接口名.”调用接口的静态方法 (JDK8.0才能开始使用)
        USB3.show();
        //通过“接口名.”直接使用接口的静态常量
        System.out.println(USB3.MAX_SPEED);
    }
}
```

**6、使用接口的默认方法**

默认方法只能被实现类的对象调用。

接口中声明的默认方法可以被实现类继承，实现类在没有重写此方法的情况下，默认调用接口中声明的默认方法；如果实现类重写了该方法，则调用的是自己重写的方法。注意类重写默认方法时，不能写default，因为default只用于在接口中表示默认方法。

**7、接口的私有方法**

只能在本接口中访问，所以只能被本接口中的默认方法或私有方法调用。


### 7.3 JDK8中相关冲突问题

#### 7.3.1 默认方法冲突问题

**（1）类优先原则**

当一个类，既继承一个父类，又实现若干个接口时，如果父类中的成员方法与接口中的默认方法的方法签名相同，假如子类没有重写该方法，则子类默认会执行父类的成员方法。

实现类中可以通过 `接口名.super.方法名` 的方式选择保留哪个接口的默认方法；可以通过 `super.方法名` 的方式选择保留父类的方法。

```java
interface Friend {
    default void date(){
        System.out.println("吃喝玩乐");
    }
}
class Father {
    public void date(){
        System.out.println("爸爸约吃饭");
    }
}
class Son extends Father implements Friend {
    @Override
    public void date() {
        //(1)不重写默认保留父类的
        //(2)调用父类的
//        super.date();
        //(3)保留父接口的
//        Friend.super.date();
        //(4)完全重写
        System.out.println("跟康师傅学Java");
    }
}
public class Test {
    public static void main(String[] args) {
        Son s = new Son();
        s.date();
    }
}
```

**（2）接口冲突**

- 当一个类同时实现了多个父接口，而多个父接口中包含方法签名相同的默认方法时，产生接口冲突。此时实现类必须重写该默认方法，不能有default关键字(因为是在类中)
- 当一个子接口同时继承了多个接口，而多个父接口中包含方法签名相同的默认方法时，也产生接口冲突。此时子接口必须重写冲突的默认方法，default关键字需要保留(因为是在接口中)


#### 7.3.2 常量冲突问题

- 当子类继承父类又实现父接口，而父类中存在与父接口常量同名的成员变量，并且该成员变量名在子类中仍然可见。
- 当子类同时实现多个接口，而多个接口存在相同同名常量。

此时在子类中想要引用父类或父接口的同名的常量或成员变量时，必须用 `接口名.super.属性名` 和 `super.属性名` 加以区分。

```java
class SuperClass {
    int x = 1;
}
interface SuperInterface {
    int x = 2;
    int y = 2;
}
interface MotherInterface {
    int x = 3;
}
class SubClass extends SuperClass implements SuperInterface, MotherInterface {
    public void method(){
//      System.out.println("x = " + x);//模糊不清
        System.out.println("super.x = " + super.x);
        System.out.println("SuperInterface.x = " + SuperInterface.x);
        System.out.println("MotherInterface.x = " + MotherInterface.x);
        System.out.println("y = " + y);//没有重名问题，可以直接访问
    }
}
```

### 7.4 接口与抽象类之间的对比

共性：都可以声明抽象方法、都不能实例化

区别：抽象类一定有构造器，接口没有构造器；类与类之间是单继承关系，类与接口之间是实现关系，接口与接口之间是多继承关系。

> 在开发中，常看到一个类不是去继承一个已经实现好的类，而是要么继承抽象类，要么实现接口。



## 8. 类的成员之五：内部类(InnerClass)

### 8.1 概述

将一个类A定义在另一个类B里面，里面的那个类A就称为`内部类（InnerClass）`，类B则称为`外部类（OuterClass）`。

作用：具体来说，当一个事物A的内部，还有一个部分需要一个完整的结构B进行描述，而这个内部的完整的结构B又只为外部事物A提供服务，不在其他地方单独使用，那么整个内部的完整结构B最好使用内部类。总的来说，遵循`高内聚、低耦合`的面向对象开发原则。

**内部类的分类**

根据内部类声明的位置（如同变量的分类），我们可以分为：**非静态成员内部类、静态成员内部类、非匿名局部内部类、匿名局部内部类**。有时候也简称为成员内部类、静态内部类、局部内部类、匿名内部类。

### 8.2 成员内部类

#### 8.2.1 概述

如果成员内部类中不使用外部类的非静态成员，那么通常将该成员内部类声明为静态成员内部类，否则声明为非静态成员内部类。

**语法格式：**

```java
[修饰符] class 外部类{
    [其他修饰符] [static] class 内部类{
    }
}
```

**成员内部类的使用特征，概括来讲有如下两种角色：**

- 成员内部类作为`类的成员的角色`：
  - 和外部类不同，Inner class还可以声明为private或protected；
  - 可以调用外部类的结构，包括private修饰的结构；
  - Inner class 可以声明为static的，但此时就不能再使用外部类的非static成员；
- 成员内部类作为`类的角色`：
  - 可以在内部定义属性、方法、构造器、代码块、内部类等结构
  - 可以继承自己想要继承的父类，实现自己想要实现的父接口，和外部类的父类和父接口无关
  - 可以声明为abstract类 ，因此可以被其它的内部类继承
  - 可以声明为final的，表示不能被继承
  - 编译以后生成OuterClass$InnerClass.class字节码文件（也适用于局部内部类）


#### 8.2.2 创建成员内部类对象

假设`Person`是外部类，`Dog`是其静态成员内部类，`Bird`是其非静态成员内部类：

- 实例化静态成员内部类

```java
Person.Dog dog = new Person.Dog();
```

- 实例化非静态成员内部类

```java
// 方式1：
Person p1 = new Person();
Person.Bird bird = p1.new Bird();
// 方式2：
Person.Bird bird1 = new Person().new Bird();
```


举例：
```java
public class Test {
    public static void main(String[] args) {
        // 1. 创建静态成员内部类的实例
        Person.Dog dog = new Person.Dog();
        dog.eat();

        // 2. 创建非静态的成员内部类的实例
        Person p1 = new Person();
        Person.Bird bird = p1.new Bird();
        bird.eat();
        // 也可以简写，即 Person.Bird bird1 = new Person().new Bird();

        bird.show("666"); // 22 666 小鸟 Tom
        p1.func(); // 1 2
    }
}

class Person {
    String name = "Tom";
    int age = 22;
    static class Dog {
        static int id1 = 1;
        int id2 = 2;
        public void eat() {
            System.out.println("狗吃骨头");
        }
    }
    class Bird {
        String name = "小鸟";
        public void eat() {
            System.out.println("鸟吃虫子");
        }
        public void show(String name) {
            System.out.println("age = " + age); // 省略了Person.this
            System.out.println("name = " + name);
            System.out.println("name = " + this.name);
            System.out.println("name = " + Person.this.name);
        }
    }
    public void func() {
        System.out.println(Dog.id1);
        System.out.println(new Dog().id2);
    }
}
```

注意：
- 成员内部类的实例方法中，要拿到当前外部类对象，格式是：`外部类名.this.成员`
- 外部类访问成员内部类的成员，需要 `内部类.成员` 或 `内部类对象.成员` 的方式


### 8.3 局部内部类

#### 8.3.1 非匿名局部内部类

语法格式：

```java
[修饰符] class 外部类{
    [修饰符] 返回值类型  方法名(形参列表){
            [final/abstract] class 内部类{
    	}
    }    
}
```

非匿名的局部内部类是定义在在方法中、代码块中、构造器等执行体中的类，和局部变量一样，只能在方法中有效。一般在开发中较少使用。

#### 8.3.2 匿名局部内部类


> **1. 认识匿名内部类，基本使用**

匿名内部类是一种特殊的局部内部类；所谓匿名，指的是程序员不需要为这个类声明名字。

下面就是匿名内部类的格式：

```java
new 父类/接口(参数值) {
    @Override
    重写父类/接口的方法
};
```

**匿名内部类本质就是一个子类，并会立即创建出一个子类对象**。也就是说`new A() {}` 实际创建的是 `A` 的一个**匿名子类的对象**。

```java
public class Test {
    public static void main(String[] args) {
        go(new Crying() {
            @Override
            public void cry() {
                System.out.println("汪汪汪");
            }
        });
    }
    public static void go(Crying s) {
        s.cry();
    }
}
interface Crying {
    void cry();
}
```

需要注意的是，匿名内部类在编写代码时没有名字，编译后系统会为自动为匿名内部类生产字节码，字节码的名称会以`外部类$1.class`的方法命名。

**匿名内部类的作用：简化了创建子类对象、实现类对象的书写格式。**

> **2. 匿名内部类的应用场景**

**在调用方法时，当方法的形参是一个接口或者抽象类，为了简化代码书写，而直接传递匿名内部类对象给方法**。这样就可以少写一个类，所以匿名内部类通常作为一个参数传输给方法。

**注意，我们通过匿名内部类可以创建接口匿名实现类的匿名对象，从而通过父类或父接口的变量多态引用匿名内部类的匿名对象。这是在开发中最常见的用法。**

**练习**：

编写一个匿名内部类，它继承Object，并在匿名内部类中，声明一个方法`public void test()`打印尚硅谷。

```java
public class Test {
    public static void main(String[] args) {
        new Object() {
            public void test() {
                System.out.println("尚硅谷");
            }
        }.test();
    }
}
```

## 9. 枚举类

### 9.1 概述

- 枚举类型本质上也是一种类，只不过是这个类的对象是有限的、固定的几个，不能让用户随意创建。开发中，当需要定义一组常量时，强烈建议使用枚举类。
- **若枚举只有一个对象, 则可以作为一种单例模式的实现方式**。例如：

```java
public enum C {
    X; //单例
}
```

- 枚举类的实现：在JDK5.0 之后，Java支持`enum`关键字来快速定义枚举类型。

### 9.2 定义枚举类（JDK5.0 之后）

#### 9.2.1 enum关键字声明枚举

```java
[修饰符] enum 枚举类名{
    常量对象列表;
    其他成员/方法;
}
```

#### 9.2.2 enum方式定义的要求和特点

* 枚举类的常量对象列表必须在枚举类的首行，因为是常量，所以建议大写。列出的枚举常量对象，系统会自动添加 public static final 修饰。
* 枚举类的构造器都是私有的（写不写都只能是私有的），因此，枚举类对外不能创建对象。
* 编译器给枚举类默认提供的是private的无参构造，如果枚举类需要的是无参构造，就不需要声明，写常量对象列表时也不用加参数。
* 如果枚举类需要的是有参构造，需要手动定义，有参构造的private可以省略，调用有参构造的方法就是在常量对象名后面加(实参列表)就可以。
* 枚举类默认继承的是java.lang.Enum类，因此不能再继承其他的类。
* 枚举类是最终类，不可以被继承。
* JDK5.0 之后switch，提供支持枚举类型，case后面可以写枚举常量名，无需添加枚举类作为限定。

### 9.3 enum中常用方法

```java
// 默认返回当前枚举常量的名称，可以手动重写该方法
String toString();

// 返回当前枚举常量的名称
String name();

// 返回所有枚举类型对象的数组
static 枚举类型[] values();

// 返回当前枚举类中名称为str的枚举类对象，如果不存在，则产生运行时异常
static 枚举类型 valueOf(String str);
    
// 返回当前枚举常量的索引，默认从0开始
int ordinal();
```

举例：

```java
public class Test {
    public static void main(String[] args) {
        // 想要获取枚举类中的枚举项，需要用类名调用
        SeasonEnum s = SeasonEnum.SPRING;
        // 1. toString()
        System.out.println(s); // SPRING
        // 2. name()
        System.out.println(SeasonEnum.SUMMER.name()); // SUMMER
        // 3. values()
        SeasonEnum[] arr = SeasonEnum.values();
        System.out.println(Arrays.toString(arr)); // [SPRING, SUMMER, AUTUMN, WINTER]
        // 4. valueOf(str)
        SeasonEnum obj = SeasonEnum.valueOf("AUTUMN");
        System.out.println(obj); // AUTUMN
        // 5. ordinal()
        System.out.println(SeasonEnum.WINTER.ordinal()); // 3
    }
}

enum SeasonEnum {
    SPRING("春天","春风又绿江南岸"),
    SUMMER("夏天","映日荷花别样红"),
    AUTUMN("秋天","秋水共长天一色"),
    WINTER("冬天","窗含西岭千秋雪");

    private String seasonName;
    private String seasonDesc;

    private SeasonEnum(String seasonName, String seasonDesc) {
        this.seasonName = seasonName;
        this.seasonDesc = seasonDesc;
    }
    public String getSeasonName() {
        return seasonName;
    }
    public String getSeasonDesc() {
        return seasonDesc;
    }
}
```

### 9.4 实现接口的枚举类

和普通 Java 类一样，枚举类可以实现一个或多个接口。

**方式1**：若每个枚举值在调用实现的接口方法呈现相同的行为方式，则只要统一实现该方法即可。

```java
public class Test {
    public static void main(String[] args) {
        Status.WIN.show(); // 游戏结束！
        Status.LOSE.show(); // 游戏结束！
    }
}
interface Show {
    void show();
}
enum Status implements Show{
    WIN, LOSE;
    @Override
    public void show() {
        System.out.println("游戏结束！");
    }
}
```

**方式2**：若需要每个枚举值在调用实现的接口方法呈现出不同的行为方式，则可以让每个枚举值分别来实现该方法

```java
public class Test {
    public static void main(String[] args) {
        Status.WIN.show(); // 游戏胜利！
        Status.LOSE.show(); // 游戏失败！
    }
}
interface Show {
    void show();
}
enum Status implements Show{
    WIN() {
        @Override
        public void show() {
            System.out.println("游戏胜利！");
        }
    }, LOSE() {
        @Override
        public void show() {
            System.out.println("游戏失败！");
        }
    };
}
```

**补充(抽象枚举)**：枚举类中也可以直接定义抽象方法，不过必须让每个枚举值来实现该方法。

```java
public class Test {
    public static void main(String[] args) {
        Status.WIN.show(); // 游戏胜利！
        Status.LOSE.show(); // 游戏失败！
    }
}
enum Status{
    WIN() {
        @Override
        public void show() {
            System.out.println("游戏胜利！");
        }
    }, LOSE() {
        @Override
        public void show() {
            System.out.println("游戏失败！");
        }
    };
    public abstract void show();
}
```

### 9.5 枚举的应用场景

枚举的应用场景是这样的：**枚举一般表示一组信息，然后作为参数进行传输。**

如果选择定义一个一个的常量来表示一组信息，并作为参数传输，则参数值不受约束。但如果选择定义枚举表示一组信息，并作为参数传输，则代码可读性好，参数值得到了约束，对使用者更友好。

```java
enum Constant{
    BOY, GIRL;
}
public class Test{
    public static void main(String[] args){
        //调用方法，传递男生
        provideInfo(Constant.BOY);
    }
    
    public static void provideInfo(Constant c){
        switch(c){
            case BOY:
                System.out.println("展示一些信息给男生看");
                break;
            case GIRL:
                System.out.println("展示一些信息给女生看");
                break;
        }
    }
}
```


## 10. 注解(Annotation)

### 10.1 注解概述

#### 10.1.1 什么是注解

注解（Annotation）是从`JDK5.0`开始引入，以“`@注解名`”在代码中存在，它是代码中的特殊标记，作用是：让其他程序根据注解信息决定怎么执行该程序。

Annotation 可以像修饰符一样被使用，可用于修饰包、类、构造器、方法、成员变量、参数、局部变量的声明。还可以添加一些参数值，这些信息被保存在 Annotation 的 “name=value” 对中。

注解可以在类编译、运行时进行加载，体现不同的功能。

#### 10.1.2 注解与注释

注解也可以看做是一种注释，通过使用 Annotation，程序员可以在不改变原有逻辑的情况下，在源文件中嵌入一些补充信息。但是，注解，不同于单行注释和多行注释。

- 对于单行注释和多行注释是给程序员看的。
- 而注解是可以被编译器或其他程序读取的。程序还可以根据注解的不同，做出相应的处理。

#### 10.1.3 注解的重要性

在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在`JavaEE/Android中注解占据了更重要的角色`，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的`繁冗代码`和`XML配置`等。

未来的开发模式都是基于注解的，JPA是基于注解的，Spring2.5以上都是基于注解的，Hibernate3.x以后也是基于注解的，Struts2有一部分也是基于注解的了。`注解是一种趋势`，一定程度上可以说：`框架 = 注解 + 反射 + 设计模式`。

### 10.2 常见的Annotation作用

**示例1：生成文档相关的注解**

```java
@author 标明开发该类模块的作者，多个作者之间使用,分割
@version 标明该类模块的版本
@see 参考转向，也就是相关主题
@since 从哪个版本开始增加的
@param 对方法中某参数的说明，如果没有参数就不能写
@return 对方法返回值的说明，如果方法的返回值类型是void就不能写
@exception 对方法可能抛出的异常进行说明 ，如果方法没有用throws显式抛出的异常就不能写
```

```java
package com.annotation.javadoc;
/**
 * @author 尚硅谷-宋红康
 * @version 1.0
 * @see Math.java
 */
public class JavadocTest {
	/**
	 * 程序的主方法，程序的入口
	 * @param args String[] 命令行参数
	 */
	public static void main(String[] args) {
	}
	
	/**
	 * 求圆面积的方法
	 * @param radius double 半径值
	 * @return double 圆的面积
	 */
	public static double getArea(double radius){
		return Math.PI * radius * radius;
	}
}
```

**示例2：在编译时进行格式检查(JDK内置的三个基本注解)**

`@Override`: 限定重写父类方法，该注解只能用于方法

`@Deprecated`: 用于表示所修饰的元素(类，方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择

`@SuppressWarnings`: 抑制编译器警告

```java
package com.annotation.javadoc;
 
public class AnnotationTest{
 
	public static void main(String[] args) {
		@SuppressWarnings("unused")
		int a = 10;
	}
	@Deprecated
	public void print(){
		System.out.println("过时的方法");
	}
 
	@Override
	public String toString() {
		return "重写的toString方法()";
	}
}

```

**示例3：跟踪代码依赖性，实现替代配置文件功能**

- Servlet3.0提供了注解(annotation)，使得不再需要在web.xml文件中进行Servlet的部署。

```java
@WebServlet("/login")
public class LoginServlet extends HttpServlet {
    private static final long serialVersionUID = 1L;
    
    protected void doGet(HttpServletRequest request, HttpServletResponse response) { }
    
    protected void doPost(HttpServletRequest request, HttpServletResponse response) {
        doGet(request, response);
	}  
}

```

```xml
 <servlet>
    <servlet-name>LoginServlet</servlet-name>
    <servlet-class>com.servlet.LoginServlet</servlet-class>
  </servlet>
  <servlet-mapping>
    <servlet-name>LoginServlet</servlet-name>
    <url-pattern>/login</url-pattern>
  </servlet-mapping>

```

- Spring框架中关于“事务”的管理

```java
@Transactional(propagation=Propagation.REQUIRES_NEW,isolation=Isolation.READ_COMMITTED,readOnly=false,timeout=3)
public void buyBook(String username, String isbn) {
	//1.查询书的单价
    int price = bookShopDao.findBookPriceByIsbn(isbn);
    //2. 更新库存
    bookShopDao.updateBookStock(isbn);	
    //3. 更新用户的余额
    bookShopDao.updateUserAccount(username, price);
}

```

```xml
<!-- 配置事务属性 -->
<tx:advice transaction-manager="dataSourceTransactionManager" id="txAdvice">
       <tx:attributes>
       <!-- 配置每个方法使用的事务属性 -->
       <tx:method name="buyBook" propagation="REQUIRES_NEW" 
	 isolation="READ_COMMITTED"  read-only="false"  timeout="3" />
       </tx:attributes>
</tx:advice>

```

### 10.3 三个最基本的注解

#### 10.3.1 @Override

- 用于检测被标记的方法为有效的重写方法，如果不是，则报编译错误！


- 只能标记在方法上。


- 它会被编译器程序读取。


#### 10.3.2 @Deprecated

- 用于表示被标记的数据已经过时，不推荐使用。


- 可以用于修饰 属性、方法、构造、类、包、局部变量、参数。


- 它会被编译器程序读取。


#### 10.3.3 @SuppressWarnings

- 抑制编译警告。当我们不希望看到警告信息的时候，可以使用 SuppressWarnings 注解来抑制警告信息


- 可以用于修饰类、属性、方法、构造、局部变量、参数


- 它会被编译器程序读取。

- 可以指定的警告类型有（了解）
  - all，抑制所有警告
  - unchecked，抑制与未检查的作业相关的警告
  - unused，抑制与未用的程式码及停用的程式码相关的警告
  - deprecation，抑制与淘汰的相关警告
  - nls，抑制与非 nls 字串文字相关的警告
  - null，抑制与空值分析相关的警告
  - rawtypes，抑制与使用 raw 类型相关的警告
  - static-access，抑制与静态存取不正确相关的警告
  - static-method，抑制与可能宣告为 static 的方法相关的警告
  - super，抑制与置换方法相关但不含 super 呼叫的警告
  - ...

示例代码：

```java
package com.atguigu.annotation;

import java.util.ArrayList;

public class TestAnnotation {
    @SuppressWarnings("all")
    public static void main(String[] args) {
        int i;

        ArrayList list = new ArrayList();
        list.add("hello");
        list.add(123);
        list.add("world");

        Father f = new Son();
        f.show();
        f.methodOl();
    }
}

class Father{
    @Deprecated
    void show() {
        System.out.println("Father.show");
    }
    void methodOl() {
        System.out.println("Father Method");
    }
}

class Son extends Father{
/*	@Override
	void method01() {
		System.out.println("Son Method");
	}*/
}
```

### 10.4 元注解

元注解：对现有的注解进行解释说明的注解。

JDK1.5在java.lang.annotation包定义了4个标准的meta-annotation类型，它们被用来提供对其它annotation类型作说明。

（1）**@Target**：约束自定义注解只能在哪些地方使用

- 可以通过枚举类型ElementType的10个常量对象来指定
  - TYPE：类，接口
  - FIELD：成员变量
  - METHOD：成员方法
  - PARAMETER：方法参数
  - CONSTRUCTOR：构造器
  - LOCAL_VARIABLE：局部变量
- 举例：`@Target(ElementType.TYPE)`

（2）**@Retention**：用于描述注解的生命周期

- 可以通过枚举类型RetentionPolicy的3个常量对象来指定
  - SOURCE：注解只作用在源码阶段，生成的字节码文件中不存在
  - CLASS（默认值）：注解保留到字节码文件阶段，运行阶段不存在
  - RUNTIME（开发常用）：注解一直保留到运行阶段，所以唯有RUNTIME阶段才能被反射读取到
- 举例：`@Retention(RetentionPolicy.RUNTIME)`

（3）**@Documented**：表明这个注解应该被javadoc工具记录。

（4）**@Inherited**：允许子类继承父类中的注解


### 10.5 自定义注解的使用


#### 10.5.1 声明自定义注解

```java
【元注解】
【修饰符】 @interface 注解名{
    public 属性类型 属性名() default 默认值;
    ...
}
```

**注解的本质**：通过对注解的字节码反编译后，我们会发现

- MyTest1注解本质上是接口，且继承了Annotation接口
- MyTest1注解中的属性本质上是抽象方法
- `@MyTest1`实际上是作为MyTest1接口的实现类对象
- `@MyTest1(aaa="孙悟空", bbb=false, ccc={"Python","前端","Java"})`里面的属性值，可以通过调用aaa()、bbb()、ccc()方法获取到

![](/zzimages/1669604928912.png)

**注意**：
- 自定义注解可以通过四个元注解@Retention, @Target, @Inherited, @Documented来进行说明。
- Annotation 的成员在 Annotation 定义中以无参数有返回值的抽象方法的形式来声明，我们又称为配置参数。返回值类型只能是八种基本数据类型、String类型、Class类型、enum类型、Annotation类型、以上所有类型的数组
- 可以使用 default 关键字为抽象方法指定默认返回值
- 如果定义的注解含有抽象方法，那么使用时必须指定返回值，除非它有默认值。格式是`方法名 = 返回值`，如果只有一个抽象方法需要赋值，且方法名为`value`，可以省略`value=`，所以如果注解只有一个抽象方法成员，建议使用方法名value。


举例：
```java
@Inherited
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface Table {
    String value();
}
```

```java
@Inherited
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Column {
    String columnName();
    String columnType();
}
```

#### 10.5.2 使用自定义注解

```java
@Table("t_stu")
public class Student {
    @Column(columnName = "sid",columnType = "int")
    private int id;
    @Column(columnName = "sname",columnType = "varchar(20)")
    private String name;
}
```

#### 10.5.3 解析自定义注解

自定义注解必须配上注解的信息处理流程才有意义。我们自己定义的注解，只能使用反射的代码读取，所以自定义注解的生命周期必须是`RetentionPolicy.RUNTIME`。

注解在哪个成分上，我们就先拿哪个成分对象：
- 比如注解作用成员方法，则要获得该成员方法对应的Method对象，再来拿上面的注解
- 比如注解作用在类上，则要该类的Class对象，再来拿上面的注解
- 比如注解作用在成员变量上，则要获得该成员变量对应的Field对象，再来拿上面的注解

**与注解解析相关的接口**

- Annotation: 注解的顶级接口，注解都是Annotation类型的对象
- AnnotatedElement:该接口定义了与注解解析相关的解析方法
  - `Annotation[] getDeclaredAnnotations()`：获得当前对象上使用的所有注解，返回注解数组
  - `T getDeclaredAnnotation(Class<T> annotationClass)`：根据注解类型获得对应注解对象
  - `boolean isAnnotationPresent(Class<Annotation> annotationClass)`：判断当前对象是否使用了指定的注解，如果使用了则返回true，否则false

注意：所有的类成分Class, Method, Field, Constructor都实现了AnnotatedElement接口，因此他们都拥有解析注解的能力。

```java
public static void main(String[] args) {
    // 先得到Class对象
    Class studentClass = Student.class;
    // 获取类上的注解
    Table tableAnnotation = (Table) studentClass.getDeclaredAnnotation(Table.class);
    String tableName = "";
    if (tableAnnotation != null){
        // 调用注解中的方法获取对应的值
        tableName = tableAnnotation.value();
    }

    // 获取Field对象
    Field[] declaredFields = studentClass.getDeclaredFields();
    String[] columns = new String[declaredFields.length];
    int index = 0;
    for (Field declaredField : declaredFields) {
        // 获取每个成员变量上的注解
        Column column = declaredField.getDeclaredAnnotation(Column.class);
        if (column!= null) {
            // 调用注解中的方法获取对应的值
            columns[index++] = column.columnName();
        }
    }
    
    String sql = "select ";
    for (int i=0; i<index; i++) {
        sql += columns[i];
        if(i<index-1){
            sql += ",";
        }
    }
    sql += " from " + tableName;
    System.out.println("sql = " + sql);
}
```


### 10.6 JUnit单元测试

#### 10.6.1 测试分类

**黑盒测试**：不需要写代码，给输入值，看程序是否能够输出期望的值。 

**白盒测试**：需要写代码的。关注程序具体的执行流程。

#### 10.6.2 JUnit单元测试介绍

JUnit 是由 Erich Gamma 和 Kent Beck 编写的一个测试框架（regression testing framework），供Java开发人员编写单元测试之用。

**JUnit测试是程序员测试，即所谓白盒测试，因为程序员知道被测试的软件如何（How）完成功能和完成什么样（What）的功能。**

要使用JUnit，必须在项目的编译路径中`引入JUnit的库`，即相关的.class文件组成的jar包。jar就是一个压缩包，压缩包都是开发好的第三方（Oracle公司第一方，我们自己第二方，其他都是第三方）工具类，都是以class文件形式存在的。

#### 10.6.3 引入本地JUnit.jar

第1步：在项目中File-Project Structure中操作：添加Libraries库

![](/zzimages/image-20211228180938922.png)

![](/zzimages/image-20221002195547325.png)

其中，junit-libs包内容如下：

![](/zzimages/image-20220813005206452.png)

第2步：选择要在哪些module中应用JUnit库

![](/zzimages/image-20220813005511062.png)

第3步：检查是否应用成功

![](/zzimages/image-20220813005729233.png)

**注意Scope：选择Compile，否则编译时，无法使用JUnit。**

第4步：下次如果有新的模块要使用该libs库，这样操作即可

![](/zzimages/image-20220813005944022.png)

![](/zzimages/image-20220813010018152.png)

![](/zzimages/image-20220813010055217.png)

![](/zzimages/image-20220813010124381.png)

#### 10.6.4 编写和运行@Test单元测试方法

JUnit4版本，要求@Test标记的方法必须满足如下要求：

- 所在的类必须是public的，非抽象的，包含唯一的无参构造器。
- @Test标记的方法本身必须是public，非抽象的，非静态的，void无返回值，()无参数的。

```java
package com.atguigu.junit;

import org.junit.Test;

public class TestJUnit {
    @Test
    public void test01(){
        System.out.println("TestJUnit.test01");
    }

    @Test
    public void test02(){
        System.out.println("TestJUnit.test02");
    }

    @Test
    public void test03(){
        System.out.println("TestJUnit.test03");
    }
}
```

![](/zzimages/image-20220106152412245.png)

#### 10.6.5 设置执行JUnit用例时支持控制台输入

**1. 设置数据：**

默认情况下，在单元测试方法中使用Scanner时，并不能实现控制台数据的输入。需要做如下设置：

在`idea64.exe.vmoptions配置文件`中加入下面一行设置，重启idea后生效。

```properties
-Deditable.java.test.console=true
```

**2. 配置文件位置：**

![](/zzimages/image-20220813011625546.png)

![](/zzimages/image-20220813011642180.png)

添加完成之后，重启IDEA即可。

**3. 如果上述位置设置不成功，需要继续修改如下位置**

修改位置1：IDEA安装目录的bin目录（例如：`D:\develop_tools\IDEA\IntelliJ IDEA 2022.1.2\bin`）下的idea64.exe.vmoptions文件。 

修改位置2：C盘的用户目录`C:\Users\用户名\AppData\Roaming\JetBrains\IntelliJIdea2022.1` 下的`idea64.exe.vmoptions`件。

#### 10.6.6 定义test测试方法模板

选中自定义的模板组，点击”+”（1.Live Template）来定义模板。

![](/zzimages/image-20211229100040505.png)

#### 10.6.7 断言机制

在单元测试中，我们可以使用断言机制。**所谓断言：意思是程序员可以预测程序的运行结果，检查程序的运行结果是否与预期一致**。例如

```java
//断言机制：预测index2的结果
//第1个参数是输出的错误信息，第2个参数是预期的结果，第3个参数是实际测试的结果
Assert.assertEquals("方法内部有Bug", 4, index2);
```

运行测试方法，结果如下图所示，表示我们预期值与实际值不一致：

![](/zzimages/1668508226111.png)

#### 10.6.8 JUnit框架的常用注解

![](/zzimages/20230808115810.png)

![](/zzimages/20230808115836.png)


## 11. 包装类

### 11.1 包装类简介

Java提供了两个类型系统，`基本数据类型`与`引用数据类型`。使用基本数据类型在于效率，然而当要使用只针对对象设计的API或新特性时就需要包装类。

Java针对八种基本数据类型定义了相应的引用类型：包装类（封装类）。有了类的特点，就可以调用类中的方法，Java才是真正的面向对象。

![](/zzimages/image-20220329001912486.png)


### 11.2 包装类与基本数据类型间的转换

**装箱：把基本数据类型转为包装类对象**

传统方式：
```java
// 1. 使用包装类的构造器，这种方式已经过时
Integer obj1 = new Integer(4);
// 2. 使用包装类的静态方法 valueOf(数据)
Integer obj2 = Integer.valueOf(4);
```

**拆箱：把包装类对象拆为基本数据类型**

传统方式：
```java
// 调用包装类的 xxxValue() 方法
int num1 = obj1.intValue();
```

**自动装箱与自动拆箱：**

由于我们经常要做基本类型与包装类之间的转换，从`JDK5.0 `开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如：

```java
Integer i = 4; //自动装箱，底层调用了valueOf 方法
int ii = i; //自动拆箱，底层调用了xxxValue 方法
i = i + 5; 
//等号右边：将i对象转成基本数据类型(自动拆箱)，即 i.intValue() + 5;
//加法运算完成后，再次自动装箱，把基本数据类型转成引用数据类型。
```

> 注意：只能与自己对应的类型之间才能实现自动装箱与拆箱。


### 11.3 基本数据类型、包装类与字符串间的转换

**（1）基本数据类型、包装类转为字符串**

**方式1**：调用包装类提供的toString方法，静态和非静态都有。

```java
Integer b = 20;
String s1 = Integer.toString(10); // 静态
String s2 = b.toString(); // 非静态
```

**方式2**：调用String提供的valueOf()静态方法

```java
Integer b = 20;
String s1 = String.valueOf(10);
String s2 = String.valueOf(b);
```

**方式3(推荐)**：直接与空字符串连接

```java
Integer b = 20;
String s1 = 10 + "";
String s2 = c + "";
```

**（2）字符串转为基本数据类型、包装类**

**方式1**：调用包装类的 parseXxx 静态方法。除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本数据类型，例如：

* `public static int parseInt(String s)`：将字符串参数转换为对应的int基本类型。
* `public static double parseDouble(String s)`：将字符串参数转换为对应的double基本类型。

```java
int a = Integer.parseInt("123");
Integer b = Integer.parseInt("456");
```

**方式2(推荐)**：调用包装类的 valueOf 静态方法。字符串转为包装类，然后可以自动拆箱为基本数据类型。例如

* ```public static Integer valueOf(String s)```：将字符串参数转换为对应的Integer包装类
* ```public static Double valueOf(String s)```：将字符串参数转换为对应的Double包装类

```java
int a = Integer.valueOf("123");
Integer b = Integer.valueOf("456");
```

注意:如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出`java.lang.NumberFormatException`异常。


### 11.4 包装类的其它API

#### 11.4.1 数据类型的最大最小值

```java
Integer.MAX_VALUE和Integer.MIN_VALUE
    
Long.MAX_VALUE和Long.MIN_VALUE
    
Double.MAX_VALUE和Double.MIN_VALUE
```

#### 11.4.2 字符转大小写

```java
Character.toUpperCase('x');

Character.toLowerCase('X');
```

#### 11.4.3 整数转进制

```java
Integer.toBinaryString(int i) 
    
Integer.toHexString(int i)
    
Integer.toOctalString(int i)
```

#### 11.4.4 比较的方法

```java
Double.compare(double d1, double d2)
    
Integer.compare(int x, int y) 
```

### 11.5 包装类对象的特点

#### 11.5.1 包装类缓存对象

| 包装类    | 缓存对象    |
| --------- | ----------- |
| Byte      | -128~127    |
| Short     | -128~127    |
| Integer   | -128~127    |
| Long      | -128~127    |
| Float     | 没有        |
| Double    | 没有        |
| Character | 0~127       |
| Boolean   | true和false |

```java
/*
根据valueOf的底层原理，当int数值在-128~127的范围内时，
会从一个固定长度为256的数组中去找对应的Integer对象。
若int数值不在-128~127这个范围内，则会new一个新对象。
*/
Integer a = 1;
Integer b = 1;
System.out.println(a == b);//true

Integer i = 128;
Integer j = 128;
System.out.println(i == j);//false

Integer m = new Integer(1);//新new的在堆中
Integer n = 1;//这个用的是缓冲的常量对象，在方法区
System.out.println(m == n);//false

Integer x = new Integer(1);//新new的在堆中
Integer y = new Integer(1);//另一个新new的在堆中
System.out.println(x == y);//false
```

```java
Double d1 = 1.0;
Double d2 = 1.0;
System.out.println(d1==d2);//false 比较地址，没有缓存对象，每一个都是新new的
```

#### 11.5.2 类型转换问题

```java
Integer i = 1000;
double j = 1000;
System.out.println(i == j);//true  
// 会先将i自动拆箱为int，然后根据基本数据类型“自动类型转换”规则，转为double比较
```

```java
Integer i = 1000;
int j = 1000;
System.out.println(i == j);//true 
// 会自动拆箱，按照基本数据类型进行比较
```

```java
Integer i = 1;
Double d = 1.0
System.out.println(i == d);//编译报错
```

#### 11.5.3 包装类对象不可变

Integer等包装类对象是不可变对象，即一旦修改就变成了新对象。如 `Integer b = 0; b += 10;` 其中 `b += 10;` 就等价于 `b = new Integer(b + 10);`

```java
public class TestExam {
	public static void main(String[] args) {
		int i = 1;
		Integer j = new Integer(2);
		Circle c = new Circle();
		change(i,j,c);
		System.out.println("i = " + i);//1
		System.out.println("j = " + j);//2
		System.out.println("c.radius = " + c.radius);//10.0
	}
	
	/*
	 * 方法的参数传递机制：
	 * （1）基本数据类型：形参的修改完全不影响实参
	 * （2）引用数据类型：通过形参修改对象的属性值，会影响实参的属性值
	 * 这类Integer等包装类对象是“不可变”对象，即一旦修改，就是新对象，和实参就无关了
	 */
	public static void change(int a ,Integer b,Circle c ){
		a += 10;
		b += 10;//等价于 b = new Integer(b+10);
		c.radius += 10;
	}
}
class Circle{
	double radius;
}
```

**练习**：如下两个题目输出结果相同吗？各是什么。

```java
Object o1 = true ? new Integer(1) : new Double(2.0);
System.out.println(o1);//1.0
// 三元运算符需要两个表达式类型兼容，赋值时会提升到同一个类型
```

```java
Object o2;
if (true)
    o2 = new Integer(1);
else
    o2 = new Double(2.0);
System.out.println(o2);//1
```

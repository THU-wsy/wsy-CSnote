# 第01章_计算机网络

## 1. 基础知识

### 1.1 OSI七层模型是什么

### 1.2 TCP/IP四层模型是什么

### 1.3 应用层的主要协议有哪些

- **HTTP（Hypertext Transfer Protocol，超文本传输协议）**：基于 TCP 协议，主要是为 Web 浏览器与 Web 服务器之间的通信而设计的
- **SMTP（Simple Mail Transfer Protocol，简单邮件发送协议）**：基于 TCP 协议，是一种用于发送电子邮件的协议。注意：SMTP 协议只负责邮件的发送，而不是接收。要从邮件服务器接收邮件，需要使用 POP3 或 IMAP 或 HTTP 协议。
- **POP3/IMAP（邮件接收协议）**：基于 TCP 协议，两者都是负责邮件接收的协议。IMAP 协议是比 POP3 更新的协议，它在功能和性能上都更加强大，几乎所有现代电子邮件客户端和服务器都支持 IMAP。
- **FTP（File Transfer Protocol，文件传输协议）** : 基于 TCP 协议，是一种用于在计算机之间传输文件的协议。注意：FTP 是一种不安全的协议，因为它在传输过程中不会对数据进行加密。建议在传输敏感数据时使用更安全的协议，如 SFTP。
- **Telnet（远程登陆协议）**：基于 TCP 协议，用于通过一个终端登陆到其他服务器。Telnet 协议的最大缺点之一是所有数据（包括密码）均以明文形式发送，这有潜在的安全风险。所以如今很少使用 Telnet，而是使用 SSH 。
- **SSH（Secure Shell Protocol，安全的网络传输协议）**：基于 TCP 协议，通过加密和认证机制实现安全的访问和文件传输等业务。SSH 的经典用途是登录到远程电脑中执行命令，它使用C/S架构，默认端口是 22。
- **RTP（Real-time Transport Protocol，实时传输协议）**：通常基于 UDP 协议，但也支持 TCP 协议。它提供了端到端的实时传输数据的功能，但不保证实时传输质量。
- **DNS（Domain Name System，域名管理系统）**：基于 UDP 协议，用于解决域名和 IP 地址的映射问题。

### 1.4 传输层的主要协议有哪些

- **TCP（Transmission Control Protocol，传输控制协议 ）**：提供面向连接的可靠数据传输服务
- **UDP（User Datagram Protocol，用户数据协议）**：提供无连接的，尽最大努力的数据传输服务

### 1.5 网络层的主要协议有哪些

- **IP（Internet Protocol，网际协议）**：主要作用是定义数据包的格式、对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地。目前 IP 协议主要分为两种，一种是过去的 IPv4，另一种是较新的 IPv6，目前这两种协议都在使用，但后者已经被提议来取代前者。
- **ARP（Address Resolution Protocol，地址解析协议）**：ARP 协议解决的是网络层地址和链路层地址之间的转换问题。
- **ICMP（Internet Control Message Protocol，互联网控制报文协议）**：一种用于传输网络状态和错误消息的协议，常用于网络诊断和故障排除。例如，Ping 工具就使用了 ICMP 协议来测试网络连通性。
- **NAT（Network Address Translation，网络地址转换协议）**：应用于内部网到外部网的地址转换过程中。

注意，以下三个协议与网络层密切相关，但并不属于网络层协议：

- **OSPF（Open Shortest Path First，开放式最短路径优先）** ：一种内部网关协议，也是广泛使用的一种动态路由协议，基于链路状态算法，考虑了链路的带宽、延迟等因素来选择最佳路径。它是传输层协议，基于IP。
- **RIP（Routing Information Protocol，路由信息协议）**：一种内部网关协议，也是一种动态路由协议，基于距离向量算法，使用固定的跳数作为度量标准，选择跳数最少的路径作为最佳路径。它是应用层协议，基于UDP。
- **BGP（Border Gateway Protocol，边界网关协议）**：一种用来在路由选择域之间交换网络层可达性信息的路由选择协议。它是应用层协议，基于TCP。

## 2. HTTP

### 2.1 从输入URL到页面展示的过程

1. 在浏览器中输入指定网页的 URL。
2. 浏览器通过 DNS 协议，获取域名对应的 IP 地址。
3. 浏览器根据 IP 地址和端口号，向目标服务器发起一个 TCP 连接请求。
4. 浏览器在 TCP 连接上，向服务器发送一个 HTTP 请求报文，请求获取网页的内容。
5. 服务器收到 HTTP 请求报文后，处理请求，并返回 HTTP 响应报文给浏览器。
6. 浏览器收到 HTTP 响应报文后，解析响应体中的 HTML 代码，渲染网页的结构和样式，同时根据 HTML 中的其他资源的 URL（如图片、CSS、JS 等），再次发起 HTTP 请求，获取这些资源的内容，直到网页完全加载显示。
7. 浏览器在不需要和服务器通信时，可以主动关闭 TCP 连接，或者等待服务器的关闭请求。

### 2.2 HTTP状态码有哪些

### 2.3 HTTP和HTTPS的区别

### 2.4 HTTP是无状态协议，该如何保存用户状态

HTTP 是无状态（stateless）协议，也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。要想保存用户状态，可以使用Session机制，它的主要作用就是通过服务端记录用户的状态。在服务端保存 Session 的方法很多，最常用的就是内存和Redis数据库。

### 2.5 URI和URL的区别

- URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。
- URL(Uniform Resource Locator) 是统一资源定位符，可以提供该资源的路径。它是一种具体的URI，不仅可以唯一标识资源，而且还提供了定位该资源的信息。

> URI 的作用像身份证号一样，URL 的作用更像家庭住址一样

## 3. DNS

### 3.1 DNS的作用是什么

DNS（Domain Name System）域名管理系统，用于解决**域名和IP地址的映射问题**。目前 DNS 的设计采用的是分布式、层次数据库结构，DNS 是应用层协议，它可以在 UDP 或 TCP 协议之上运行（一般是UDP），端口为53。

### 3.2 DNS服务器有哪些

### 3.3 DNS劫持是什么

DNS 劫持是一种网络攻击，它通过修改 DNS 服务器的解析结果，使用户访问的域名指向错误的 IP 地址，从而导致用户无法访问正常的网站，或者被引导到恶意的网站。DNS 劫持有时也被称为 DNS 重定向、DNS 欺骗或 DNS 污染。

### 3.4 DNS的工作流程

## 4. TCP与UDP

### 4.1 TCP与UDP的区别

|                    | TCP        | UDP        |
| ------------------ | ---------- | ---------- |
| 是否面向连接       | 是         | 否         |
| 是否可靠           | 是         | 否         |
| 传输效率           | 较慢       | 较快       |
| 传输形式           | 字节流     | 数据报文段 |
| 首部开销           | 20到60字节 | 8字节      |
| 是否提供广播或多播 | 否         | 是         |

- **UDP一般用于即时通信**，比如：语音、 视频、直播等等。这些场景对传输数据的准确性要求不是特别高，比如你看视频即使少个一两帧，实际给人的感觉区别也不大。
- **TCP用于对传输准确性要求特别高的场景**，比如文件传输、发送和接收邮件、远程登录等等。

### 4.2 HTTP基于TCP还是UDP

HTTP/3.0之前是基于TCP协议的，而HTTP/3.0将弃用TCP，改用**基于UDP的QUIC协议**

### 4.3 TCP三次握手

- **一次握手**: 客户端发送带有 `SYN（seq=x）` 标志的数据包给服务端，然后客户端进入 `SYN_SENT` 状态，等待服务器的确认；
- **二次握手**: 服务端发送带有 `SYN+ACK（seq=y, ack=x+1）` 标志的数据包给客户端，然后服务端进入 `SYN_RCVD` 状态
- **三次握手**: 客户端发送带有 `ACK（ack=y+1）` 标志的数据包给服务端，然后客户端和服务器端都进入`ESTABLISHED` 状态，完成 TCP 三次握手。

#### 1、三次握手的目的是什么

三次握手的目的是建立可靠的通信信道，简单来说就是双方确认自己与对方的发送与接收是正常的。

1. **第一次握手**：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常
2. **第二次握手**：Client 确认了：自己发送、接收正常，对方发送、接收正常
3. **第三次握手**：Server 确认了：自己发送正常，对方接收正常

#### 2、只有两次握手会有什么问题

假如只采用两次握手，可能发生以下情况：

1. 客户端第一次发送SYN报文段，但因为网络堵塞迟迟没有到服务端
2. 客户端迟迟没有等到服务端的响应，于是超时重试，重新又发了SYN报文段
3. 服务端收到了SYN报文段，于是响应SYNACK报文段。由于是两次握手，服务端就直接进入了`ESTABLISHED`状态准备通信。
4. 客户端接下来与服务端通信，通信完成后关闭TCP连接
5. 此时客户端第一次发送的SYN报文段终于到达了服务端
6. 服务端收到了SYN报文段，于是响应SYNACK报文段，并再次进入`ESTABLISHED`状态准备通信
7. 而客户端早已进入`CLOSED`状态，所以服务端只能在那一直等待通信，浪费连接资源。

### 4.4 TCP四次挥手

- **第一次挥手**：客户端发送一个 `FIN（seq=x）` 标志的数据包给服务端，用来关闭客户端到服务器的数据传送。然后客户端进入 `FIN_WAIT_1` 状态。
- **第二次挥手**：服务器收到上述数据包，就发送一个 `ACK（ack=x+1）` 标志的数据包给客户端。然后服务端进入 `CLOSE_WAIT` 状态，客户端进入 `FIN_WAIT_2` 状态。之后服务端还可以继续给客户端发数据。
- **第三次挥手**：服务端发送一个 `FIN（seq=y）` 标志的数据包给客户端，请求关闭连接，然后服务端进入 `LAST_ACK` 状态。
- **第四次挥手**：客户端发送 `ACK（ACK=y+1）` 标志的数据包给服务端，然后客户端进入`TIME_WAIT`状态，该状态会持续**2MSL**(两个最长报文段寿命)时间，约30秒，若该时间段内没有收到服务端发来的新请求，则客户端就最终进入了`CLOSED`状态。服务端在收到上述数据包后直接进入 `CLOSED` 状态。

#### 1、四次挥手的目的是什么

TCP 是全双工通信，可以双向传输数据。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。

#### 2、为什么不能把服务器发送的ACK和FIN合并起来，变成三次挥手

因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复 ACK，表示接收到了断开连接的请求。等到数据发完之后再发 FIN，断开服务器到客户端的数据传送。

#### 3、如果第二次挥手时服务器的ACK没有送达客户端，会怎样

客户端没有收到ACK确认，会重新发送FIN请求

#### 4、为什么第四次挥手客户端需要等待2MSL后才进入CLOSED状态

第四次挥手时，客户端发送给服务器的 ACK 有可能丢失，如果服务端因为某些原因而没有收到 ACK 的话，服务端就会重发 FIN，如果客户端在 2MSL 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，防止 Server 没有收到 ACK 而不断重发 FIN。

> **MSL(Maximum Segment Lifetime)** : 一个片段在网络中最大的存活时间，2MSL 就是一个发送和一个回复所需的最大时间。如果直到 2MSL，Client 都没有再次收到 FIN，那么 Client 推断 ACK 已经被成功接收，则结束 TCP 连接。

### 4.5 TCP如何保证数据传输的可靠性

1. 每个TCP报文段都具有序号，可以根据序号进行排序和去重
2. 校验和
3. 超时重传机制
4. 流量控制
5. 拥塞控制

### 4.6 TCP中的缓存（发送缓存和接收缓存）有什么作用

### 4.7 ARQ协议是什么

**自动重传请求**（Automatic Repeat-reQuest，ARQ）是 OSI 模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认信息（Acknowledgements，ACK），它通常会重新发送，直到收到确认或者重试超过一定的次数。

ARQ包括停止等待ARQ协议和连续ARQ协议：

- 停止等待ARQ协议的基本原理就是每发完一个分组就停止发送，等待对方确认（回复 ACK）。如果过了一段时间后（利用超时计时器），还是没有收到 ACK 确认，就需要重新发送，直到收到确认后再发下一个分组
- 连续ARQ协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。

> 注意：重传超时时间一般会根据实际的网络情况进行动态调整，而不是简单地直接使用RTT作为超时时间。

## 5. IP

### 5.1 IP寻址如何工作

### 5.2 什么是IP地址过滤

**IP 地址过滤**就是限制或阻止特定 IP 地址范围的访问。例如，你有一个图片服务突然被某一个 IP 地址攻击，那我们就可以禁止这个 IP 地址访问图片服务。

### 5.3 NAT的作用是什么

**NAT（Network Address Translation，网络地址转换）** 允许将私有 IP 地址（如在局域网中使用的 IP 地址）映射为公有 IP 地址（在互联网中使用的 IP 地址）或者反向映射，从而实现局域网内的多个设备通过单一公有 IP 地址访问互联网。

NAT 不光可以缓解 IPv4 地址资源短缺的问题，还可以隐藏内部网络的实际拓扑结构，使得外部网络无法直接访问内部网络中的设备，从而提高了内部网络的安全性。

### 5.4 路由协议有哪些

## 6. ARP

### 6.1 什么是MAC地址

### 6.2 ARP协议的作用

### 6.3 ARP协议的工作原理

ARP表，广播问询，单播响应



# 第02章_操作系统

## 1. 基础知识

### 1.1 什么是操作系统

操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的一个软件程序。操作系统的内核（Kernel）是操作系统的核心部分，它是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性。

> 操作系统存在屏蔽了硬件层的复杂性，它就像是硬件使用的负责人，统筹着各种相关事项。

![image-20240229194811550](images/image-20240229194811550.png)

### 1.2 操作系统的主要功能有哪些

- **进程和线程的管理**：进程的创建、撤销、阻塞、唤醒，进程间的通信等。
- **存储管理**：内存、外存的分配和管理。
- **文件管理**：文件的读、写、创建及删除等。
- **设备管理**：完成设备（输入输出设备和外部存储设备等）的请求或释放，以及设备启动等功能。
- **网络管理**：操作系统管理计算机网络的配置、连接、通信和安全等。
- **安全管理**：用户的身份认证、访问控制、文件加密等，以防止非法用户对系统资源的访问和操作。

### 1.3 什么是用户态和内核态

### 1.4 为什么不能只有内核态

### 1.5 用户态和内核态是如何切换的

### 1.6 什么是系统调用

### 1.7 系统调用的过程

## 2. 进程和线程

### 2.1 进程和线程的区别

**进程（Process）** 是指计算机中正在运行的一个程序实例。

**线程（Thread）** 也被称为轻量级进程，更加轻量，多个线程可以在同一个进程中同时执行，并且共享进程的资源比如内存空间、文件句柄、网络连接等。

**进程是操作系统资源分配的基本单位，而线程是处理器调度和执行的基本单位**。同一进程内的多个线程，会共享该进程的地址空间，并且共享本进程中的一些资源（初始化数据段、未初始化数据段、堆内存段等），但每个线程有自己独立的寄存器、程序计数器和栈（因此该进程的地址空间里会有多个栈，一般系统默认为每个线程分配8MB的栈空间）。

> **同一进程内的线程间进行上下文切换时开销很小**，因为地址空间保持不变，只需切换栈、寄存器、程序计数器等不共享的数据。多核计算机中，**各个线程可占用不同的CPU并行运行**，提升效率。

### 2.2 PCB是什么

### 2.3 进程有哪几种状态

### 2.4 什么是僵尸进程和孤儿进程

### 2.5 线程间同步的方式有哪些

### 2.6 进程间通信的方式有哪些

### 2.7 进程的调度算法有哪些

## 3. 死锁

### 3.1 什么是死锁

死锁（Deadlock）是一种常见的并发问题，它是指各线程互相等待对方手里的资源，导致各线程都阻塞，无法向前推进的现象。

### 3.2 产生死锁的必要条件

### 3.3 解决死锁的方法

## 4. 文件系统

### 4.1 常见的磁盘调度算法有哪些

### 4.2 文件系统的功能

### 4.3 硬链接和软链接有什么区别

### 4.4 硬链接为什么不能跨文件系统

### 4.5 提高文件系统性能的方式有哪些

## 5. 内存管理

### 5.1 内存管理主要做了什么

- **内存的分配与回收**
- **地址转换**：将程序中的虚拟地址转换成内存中的物理地址
- **内存扩充**：当系统没有足够的内存时，利用虚拟内存技术或自动覆盖技术，从逻辑上扩充内存。
- **内存映射**：将一个文件直接映射到进程的地址空间中，这样可以通过内存指针用读写内存的办法直接存取文件内容，速度更快。
- **内存优化**：通过调整内存分配策略和回收算法来优化内存使用效率。
- **内存安全**：保证进程之间使用内存互不干扰，避免一些恶意程序通过修改内存来破坏系统的安全性。

### 5.2 什么是内存碎片

### 5.3 内存管理方式有哪些

### 5.4 虚拟内存有什么用

### 5.5 什么是虚拟地址空间

### 5.6 分段机制是什么

### 5.7 分页机制是什么

### 5.8 分页和分段有哪些共同点和区别

**共同点**：

- 都是非连续内存管理的方式。
- 都采用了地址映射的方法，将虚拟地址映射到物理地址，以实现对内存的管理和保护。

**区别**：

- 分页机制以页面为单位进行内存管理，而分段机制以段为单位进行内存管理。页的大小是固定的，而段的大小不固定。
- 页是物理单位，其大小由操作系统决定。而段则是逻辑单位，是为了满足程序对内存空间的逻辑需求而设计的，通常根据程序中数据和代码的逻辑结构来划分。
- 分段机制容易出现外部碎片。分页机制可能出现内部碎片。
- 分页机制采用了页表来完成虚拟地址到物理地址的映射；而分段机制则采用了段表来完成虚拟地址到物理地址的映射。
- 分页机制对程序没有任何要求，程序只需要按照虚拟地址进行访问即可；而分段机制需要程序员将程序分为多个段，并且显式地使用段寄存器来访问不同的段。

### 5.9 局部性原理是什么



# 第03章_MySQL

## 1. 基础知识

### 1.1 数据库范式有哪些

### 1.2 SQL分类

SQL语言在功能上主要分为如下三大类：

- **DDL（Data Definition Language，数据定义语言）**：包括创建，删除，修改数据库、表、视图、索引等数据库对象。主要的语句关键字包括`CREATE`、`DROP`、`ALTER`等。
- **DML（Data Manipulation Language，数据操作语言）**：包括添加，删除，更新，查询数据库记录。主要的语句关键字包括`INSERT`、`DELETE`、`UPDATE`、`SELECT`等。
- **DCL（Data Control Language，数据控制语言）**：包括定义数据库、表、字段、用户的访问权限和安全级别。主要的语句关键字包括`GRANT`、`REVOKE`、`COMMIT`、`ROLLBACK`、`SAVEPOINT`等。

> 说明：由于查询语句使用的非常频繁，所以有时也将查询语句单独分为一类，称为**DQL（Data Query Language，数据查询语言）**。有时也会将`COMMIT`、`ROLLBACK`单独分为一类，称为**TCL（Transaction Control Language，事务控制语言）**。

### 1.3 MySQL的基础架构

### 1.4 MyISAM和InnoDB的区别

### 1.5 介绍一下数据库分页

### 1.6 介绍一下SQL中的聚合函数

### 1.7 表跟表是怎么关联的？

### 1.8 谈谈你对SQL注入的理解

### 1.9 WHERE和HAVING有什么区别？

## 2. 字段类型

### 2.1 整数类型的UNSIGNED属性有什么用

使用 UNSIGNED 属性可以将正整数的上限提高一倍，因为它不需要存储负数值。

### 2.2 CHAR和VARCHAR的区别

**CHAR 是定长字符串，VARCHAR 是变长字符串**，如`VARCHAR(100)`表示最多能存储100个字符

> CHAR 在存储时会在右边填充空格以达到指定的长度，检索时会去掉空格

### 2.3 DECIMAL和DOUBLE的区别

DECIMAL 是定点数，FLOAT/DOUBLE 是浮点数。DECIMAL 可以存储精确的小数值，FLOAT/DOUBLE 只能存储近似的小数值。

### 2.4 DATETIME和TIMESTAMP的区别

DATETIME 类型没有时区信息，TIMESTAMP 和时区有关。TIMESTAMP 只需要使用 4 个字节的存储空间，但是 DATETIME 需要耗费 8 个字节的存储空间。所以 Timestamp 表示的时间范围更小。

## 3. 事务

### 3.1 MySQL事务的ACID特性分别是怎么实现的

### 3.2 并发事务会有哪些问题

### 3.3 MySQL的四种隔离级别是怎么实现的

### 3.4 MySQL锁的分类

### 3.5 当前读和快照读的区别

### 3.6 谈谈你对MVCC的了解

### 3.7 MySQL的RR隔离级别能否解决幻读问题

## 4. 索引

### 4.1 索引的优缺点

索引(Index)是存储引擎用于快速找到数据记录的一种数据结构。注意，索引是在存储引擎中实现的，所以每种存储引擎的索引不完全相同。

- 索引的优点：**提高数据查询的效率，减少磁盘I/O次数**
- 索引的缺点：维护索引要耗费时间，**会降低增、删、改的速度**；每个索引都对应一颗B+树，**会占用大量磁盘空间**

### 4.2 MySQL的索引为什么用B+树

不使用Hash表，原因在于：

- Hash索引只有在等值查询时效率很高，如果要进行范围查询，时间复杂度退化为`O(n)`
- Hash索引中数据的存储是无序的，所以对于`ORDER BY`查询，还需要重新排序
- 对于联合索引，Hash值是将联合索引键合并后一起来计算的，无法对单独的一个键进行查询
- 对于等值查询来说，通常Hash索引效率更高，但如果索引列的重复值很多，Hash索引效率就变低了，因为遇到Hash冲突时需要遍历桶中的单链表进行比较。

不使用AVL树，原因在于：

- AVL树在进行删除操作时，最坏需要进行`O(log n)`次旋转操作来维持树的平衡，这会增大磁盘IO次数

不使用红黑树，原因在于：

- 红黑树的高度虽然也是渐进`O(log n)`，但它的实际树高较高，所以同样会增大磁盘IO次数，查询效率变慢

不使用B树，是因为B+树是对B树的改进，B+树具有以下优势：

- 查询效率更加稳定：所有用户数据记录查询路径长度相同，都会查找到叶子结点。
- 磁盘读写代价更低：B+树的内节点中并没有保存数据记录，所以能存储的目录项记录就更多，因此结构上比B树更加矮胖，树高越小意味着IO次数越少。
- 在范围查询上B+树效率也更高：因为所有关键字都出现在B+树的叶子节点中，而叶子节点之间数据递增，且有指针连接，可以直接根据指针顺序读取。

### 4.3 索引的分类

- 按照物理实现方式，索引可以分为**聚簇索引**和**非聚簇索引**，其中非聚簇索引也称为二级索引。
- 按照作用字段个数，索引可以分为**单列索引**和**联合索引**
- 按照功能逻辑，索引可以分为**普通索引**、**唯一索引**、**主键索引**、**全文索引**、**空间索引**

### 4.4 什么是覆盖索引

### 4.5 什么是索引条件下推

### 4.6 联合索引的存储结构是什么，它的有效方式是什么

### 4.7 模糊查询语句中如何使用索引

### 4.8 索引的设计原则

### 4.9 索引失效的场景

## 5. MySQL调优

### 5.1 说一说你对MySQL优化的理解

### 5.2 EXPLAIN语句输出的各个列的作用，应该重点关注哪些列

### 5.3 该如何优化MySQL的查询

### 5.4 表中包含几千万条数据该怎么办

### 5.5 分库分表的缺点有什么

1. 不同数据库中的表，无法使用join操作
2. 如果涉及到多个数据库，则需要使用分布式事务
3. 主键往往需要使用分布式的全局唯一ID
4. GROUP BY和ORDER BY操作会变得非常复杂

### 5.6 深度分页如何优化

## 6. 主从复制

### 6.1 说一说你对redo log、undo log、binlog的了解

### 6.2 MySQL主从同步是如何实现的

### 6.3 如何实现读写分离

### 6.4 如何避免主从延迟时的数据不一致性

一般对于**实时性要求高的读操作，建议直接从master读取数据**。



# 第04章_Java框架

## 1. IoC

### 1.1 Spring Framework包含的模块有哪些

**Spring Framework主要功能模块有**：

| 功能模块       | 功能介绍                                              |
| -------------- | ----------------------------------------------------- |
| Core Container | 核心容器，在Spring环境下使用任何功能都必须基于IOC容器 |
| AOP            | 面向切面编程                                          |
| Data Access    | 提供对ORM框架的支持，以及事务管理等功能               |
| Web            | 提供了面向Web应用程序的集成功能                       |
| Test           | 提供对测试框架的支持                                  |

![image-20240304131932836](images/image-20240304131932836.png)

### 1.2 什么是IoC

### 1.3 @Component和@Bean的区别

- `@Component` 注解作用于类，而`@Bean`注解作用于方法
- `@Component`注册的bean的id默认是类名首字母小写的名称，而`@Bean`注册的bean的id默认是方法名
- `@Component`通常是通过类路径扫描来自动侦测并自动装配到 Spring 容器中，`@Bean` 注解通常是我们在标有该注解的方法中定义产生这个 bean
- `@Bean` 注解比 `@Component` 注解的自定义性更强，当我们引用第三方库中的类需要装配到 `Spring` 容器时，只能通过 `@Bean` 来实现。

### 1.4 注入Bean的注解有哪些，它们的区别是什么

注入Bean的注解主要有`@Autowired`和`@Resource`，两者的主要区别如下：

**（1）提供者不同**

- `@Autowired` 是 Spring 提供的注解
- `@Resource` 是 JDK 提供的注解（是JSR-250系列注解）

**（2）注入方式不同**

`@Autowired`的注入方式为`byType`，也就是**根据类型进行匹配**，如果匹配不到则直接抛出异常。如果匹配到多个bean，则再根据名称进行匹配：

- 若没有标注`@Qualifier`注解，则根据变量名称作为bean的id进行匹配，匹配不到则抛出异常

- 若标注了`@Qualifier`注解，则根据该注解中指定的名称作为bean的id进行匹配，匹配不到则抛出异常
  ```java
  @Autowired
  @Qualifier("userServiceImpl")
  private UserService userService;
  ```

`@Resource`的注入方式为 `byName`，也就是**根据名称进行匹配**：

- 若指定了name属性，则根据name指定的名称作为bean的id进行匹配，匹配不到则直接抛出异常
  ```java
  @Resource(name = "userServiceImpl")
  private UserService userService;
  ```

- 若没有指定name属性，则根据变量名称作为bean的id进行匹配，如果匹配不到，则再根据类型进行匹配，最终匹配不到或者匹配到多个bean都会抛出异常。

**（3）标注位置不同**

- `@Autowired` 支持在成员变量、setter方法、有参构造器、参数上使用
- `@Resource` 支持在成员变量、setter方法上使用，但不支持在构造器、参数上使用

> 注1：注解标识在成员变量上，此时就无需设置该成员变量的setter方法
>
> 注2：如果类只有一个有参构造器，则该构造器和其形参上都可以不用标注`@Autowired`，只要该形参类型的bean在容器中，就会自动注入。

### 1.5 Bean的作用域有哪些

### 1.6 Bean的生命周期

### 1.7 Bean是线程安全的吗

### 1.8 Spring框架中用到了哪些设计模式

- **工厂设计模式** : Spring 使用工厂模式通过 `BeanFactory`、`ApplicationContext` 创建 bean 对象。
- **代理设计模式** : Spring AOP 功能的实现。
- **单例设计模式** : Spring 中的 Bean 默认都是单例的。
- **模板方法模式** : Spring 中 `jdbcTemplate`、`hibernateTemplate` 等以 Template 结尾的对数据库操作的类，它们就使用到了模板方法模式。
- **包装器设计模式** : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。
- **观察者模式:** Spring事件驱动模型就是观察者模式很经典的一个应用。
- **适配器模式** : Spring AOP 的增强或通知(Advice)使用到了适配器模式，Spring MVC 中也是用到了适配器模式适配`Controller`。

### 1.9 Spring如何解决循环依赖

三级缓存相关。。。



## 2. AOP

### 2.1 什么是AOP

AOP（Aspect Oriented Programming）是一种设计思想，是软件设计领域中的**面向切面编程**，它是面向对象编程的一种补充和完善。它能够将那些与业务无关，却为业务模块所共同调用的逻辑（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。

Spring AOP是一个框架，底层使用**动态代理**来实现AOP思想，它采用的动态代理技术有以下两种：

- 如果要代理的目标对象实现了某个接口，那么Spring AOP就会使用**JDK动态代理**去创建代理对象。生成的代理类会和目标类实现相同的接口，且该代理类在`com.sun.proxy`包下，类名是`$proxy+数字`，如`$proxy4`
- 如果要代理的目标对象没有实现任何接口，那么Spring AOP就会使用**Cglib动态代理**去创建代理对象。生成的代理类会继承目标类，且该代理类和目标类在相同的包下

### 2.2 Spring AOP和AspectJ有什么区别

### 2.3 Spring AOP中通知的类型有哪些

### 2.4 多个切面的执行顺序如何控制

使用`@Order`注解标注在切面类上定义优先级，数值越小，优先级越高，该切面就套在越外面。

## 3. 事务

### 3.1 Spring管理事务的方式有哪几种

### 3.2 事务的回滚策略是什么

### 3.3 Spring事务中有哪几种隔离级别

### 3.4 Spring事务中有哪几种事务传播行为

## 4. MVC

### 4.1 MVC是什么

### 4.2 Spring MVC的核心组件有哪些

### 4.3 Spring MVC的工作流程

### 4.4 统一异常处理怎么做

### 4.5 Spring MVC的拦截器是什么

## 5. Spring Boot

### 5.1 什么是场景启动器

### 5.2 @SpringBootApplication注解的作用

### 5.3 Spring Boot自动配置原理

### 5.4 Spring Boot读取配置信息的方式

- `@Value`
- `@ConfigurationProperties`

### 5.5 Spring Boot加载配置文件的优先级

### 5.6 后端为何要做参数校验，如何做参数校验

后端做参数校验，是为了避免用户绕过浏览器直接通过一些HTTP工具向后端请求一些违法数据，并且，有时候有些业务逻辑（例如判断用户是否在数据库中）只能通过后端进行校验。

参数校验需要引入如下依赖：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-validation</artifactId>
</dependency>
```

> 其中注解的使用方式与Spring MVC中的使用相同

### 5.7 Spring Boot的启动流程

## 6. Spring Security

### 6.1 Cookie和Session的区别

### 6.2 基于Session和基于Token的校验有什么区别

### 6.3 什么是JWT

## 7. MyBatis

### 7.1 MyBatis的工作原理是什么

### 7.2 `#{}`和`${}`的区别

### 7.3 MyBatis的插件运行原理

### 7.4 什么是resultMap

### 7.5 MyBatis的动态SQL是什么



# 第05章_Redis

## 1. 基础知识

### 1.1 Redis为什么这么快

### 1.2 什么是Redis Module

Redis 从 4.0 版本开始，支持通过 Module 来扩展其功能以满足特殊的需求。这些 Module 以动态链接库（so文件）的形式被加载到 Redis 中，这是一种非常灵活的动态扩展功能的实现方式，我们每个人都可以基于 Redis 去定制化开发自己的 Module。例如，RediSearch就是被Redis官方推荐的用于实现搜索引擎的模块。

### 1.3 Redis删除过期key的策略

### 1.4 Redis内存淘汰策略有哪些

### 1.5 导致Redis阻塞的原因可能有哪些

1. 使用了时间复杂度`O(n)`的命令，如`KEYS *`
2. AOF日志记录阻塞：AOF是在命令执行完之后再记录日志，所以可能会阻塞下一条的命令（AOF记录日志是在Redis主线程中执行的）
3. 访问BigKey会产生阻塞
4. Redis进行内存页面替换（Swap）时会发生阻塞，所以我们应该尽量保证Redis有充足的可用内存

### 1.6 如何利用Redis实现分布式Session

## 2. Redis数据类型

### 2.1 存储对象是用string好还是hash好

String存储的是序列化后的整个对象数据，而Hash是对对象的每个字段单独存储。因此，当要频繁修改对象中的某个字段时，使用Hash更好。而String存储更加节省内存，缓存相同的对象，String消耗的内存约是Hash的一半。

> 因此，在绝大部分情况下我们**建议使用String来存储对象数据**。

### 2.2 String的底层实现是什么

### 2.3 zset底层为什么要使用跳表，而不是平衡树、红黑树、B+树

**平衡树**的插入、删除、查询的时间复杂度和跳表一样都是`O(log n)`，对于范围查询来说，平衡树也可以通过中序遍历的方式达到和跳表一样的效果。但是它的每一次插入或者删除操作都需要保证整颗树左右节点的绝对平衡，只要不平衡就要通过旋转操作来保持平衡，除了红黑树以外，其他大多数平衡树（例如AVL树）最坏情况需要`O(log n)`次旋转才能维持平衡，耗时极高。而跳表使用概率平衡，并不是严格强制的平衡，因此，跳表中的插入和删除速度快得多。

**红黑树**虽然插入和删除时最坏情况只有`O(1)`次旋转、`O(log n)`次染色，但是红黑树的实现比跳表复杂得多。而且，如果按照区间来查找数据，红黑树的效率没有跳表高。

**B+树**更适合作为数据库和文件系统中常用的索引结构，它的核心思想是通过尽可能少的 IO 定位到尽可能多的索引来获得查询数据。而 Redis 作为内存数据库本身就不可能存储大量的数据，所以B+树的意义并不大。

### 2.4 五种基本数据类型的底层数据结构是什么

### 2.5 应用场景问题

#### 1、如何实现购物车

#### 2、如何实现排行榜

#### 3、如何实现抽奖系统

#### 4、如何统计活跃用户

#### 5、如何统计页面UV

## 3. 缓存

### 3.1 为什么要用缓存

- 高性能：从硬盘读取数据较慢，而如果用户访问的数据是高频数据且不经常改变，就可以放在Redis缓存中，直接操作内存速度更快
- 高并发：MySQL这类的数据库QPS大概只有1w左右（QPS，Query Per Second，服务器每秒可以执行的查询次数），而Redis的QPS很容易达到10w以上，将数据库中的部分数据保存到缓存中，用户的部分请求就会直接到缓存，进而提高了系统整体的并发。

### 3.2 为什么要给某些缓存数据设置过期时间

- Redis内存是有限的，给缓存数据设置过期时间有助于缓解内存的消耗
- 有些业务需求就要求有过期时间，例如短信验证码

注意：除了string类型有自己独有设置过期时间的命令`setex`外，其他类型都需要依靠`expire`命令来设置过期时间。使用`ttl`可以查看数据还有多久过期，使用`persist`可以将一个键设置为永不过期。

### 3.3 Redis如何判断数据是否过期

Redis通过过期字典（可以看作是 hash 表）来保存数据过期的时间。过期字典的键指向 Redis 数据库中的某个 key(键)，过期字典的值是一个 long long 类型的整数，这个整数保存了 key 所指向的数据库键的过期时间（毫秒精度的 UNIX 时间戳）。

### 3.4 缓存的高并发问题有哪些，如何解决

### 3.5 常用的缓存读写策略有哪些



## 4. 单线程模型

### 4.1 什么是Redis的单线程模型

### 4.2 Redis6之前为什么不使用多线程网络IO

### 4.3 Redis6及之后为什么支持多线程网络IO

## 5. Redis事务

### 5.1 什么是Redis事务

### 5.2 Redis事务的缺点

### 5.3 如何解决Redis事务的缺点

### 5.4 WATCH命令的作用

## 6. Redis性能优化

### 6.1 Redis有哪些批量操作

### 6.2 BigKey的危害

### 6.3 BigKey的处理方式

### 6.4 HotKey的危害

### 6.5 HotKey的处理方式

### 6.6 Redis内存碎片产生的原因

## 7. Redis持久化

### 7.1 什么是RDB

### 7.2 RDB创建快照时会阻塞主线程吗

### 7.3 什么是AOF

### 7.4 AOF的工作流程

### 7.5 AOF的写回策略有哪几种

### 7.6 AOF为什么是在执行完命令之后才记录日志

关系型数据库（如 MySQL）通常都是执行命令之前记录日志（方便故障恢复），而 Redis AOF 持久化机制则是在执行完命令之后再记录日志。原因是：

- 避免额外的检查开销：在执行完命令之后再记录日志，就无需在记录日志时再对命令进行语法检查
- 在命令执行完之后再记录，就不会阻塞当前的命令执行

不过这样也带来了风险：

- 如果刚执行完命令 Redis 就宕机会导致对应的修改丢失
- 可能会阻塞后续其他命令的执行（AOF 记录日志是在 Redis 主线程中进行的）

### 7.7 什么是AOF重写

### 7.8 什么是AOF校验机制

AOF 校验机制是 Redis 在启动时对 AOF 文件进行检查，以判断文件是否完整。这个机制的原理其实非常简单，就是通过使用一种叫做 **校验和** 的数字来验证 AOF 文件。这个校验和是通过对整个 AOF 文件内容进行 CRC64 算法计算得出的数字。如果文件内容发生了变化，那么校验和也会随之改变。因此，Redis 在启动时会比较计算出的校验和与文件末尾保存的校验和（计算的时候会把最后一行保存校验和的内容给忽略掉），从而判断 AOF 文件是否完整。如果发现文件有问题，Redis 就会拒绝启动并提供相应的错误信息。AOF 校验机制十分简单有效，可以提高 Redis 数据的可靠性。

> 类似地，RDB 文件也有类似的校验机制来保证 RDB 文件的正确性。

### 7.9 RDB和AOF混合持久化是什么

### 7.10 RDB和AOF的优劣对比

- 相同数据集而言，AOF文件要远大于RDB文件，且恢复速度慢于RDB
- RDB的数据安全性(实时性)不如AOF
- RDB文件是以特定的二进制格式保存的，而AOF以**文本协议格式**写入命令，兼容性更好，且便于修改和处理

## 8. Redis高可用

### 8.1 什么是Redis主从复制

### 8.2 主从复制下会读取到过期数据吗

如果采用`EXPIRE`或`PEXPIRE`设置过期时间，则表示执行这个命令开始往后TTL时间过期。由于从节点同步执行命令可能会有网络延迟，于是就会导致主节点中该数据已经过期，但从节点中该数据尚未过期，于是用户就可能读到理论上已经过期的数据，如下图所示（T3到T4之间的数据就是理论上已经过期的数据）。

![image-20240312141735435](images/image-20240312141735435.png)

我们可以考虑使用`EXPIREAT`和`PEXPIREAT`命令，它是用绝对的Unix时间戳来设置过期的时间点，这样就不会导致用户读取到过期的数据。

### 8.3 主从节点之间是如何同步数据的

### 8.4 为什么主从全量复制使用RDB而不是AOF

- RDB文件存储的内容是经过压缩的二进制数据，文件很小；而AOF文件存储的是每一次的写命令，文件很大。所以，传输RDB文件更节省带宽，速度也更快。
- 使用RDB文件恢复数据，直接解析还原数据节课，速度很快；而使用AOF文件恢复数据，需要依次执行每个写命令，速度很慢

### 8.5 主从复制的缺点有哪些

### 8.6 什么是Redis Sentinel

### 8.7 Redis Sentinel的工作原理

### 8.8 Sentinel可以防止脑裂吗

对于一主(M1)两从(S1、S2)的架构，如果M1所在的网络和S1、S2所在的网络被隔离，哨兵就会在S1和S2中选出一个master，这就意味着发生了脑裂。如果想防止脑裂，我们可以修改Redis配置文件中主从复制相关的配置，例如配置master至少要写入一个slave。

### 8.9 Redis Cluster是什么

### 8.10 Redis Cluster是怎么进行数据分片的

### 8.11 为什么Redis Cluster使用16384个哈希槽

1. 哈希槽太多会导致心跳包太大，消耗太多带宽
2. Redis Cluster的主节点通常不会太多，16384个哈希槽已经足够用了
3. 哈希槽总数越少，对存储哈希槽信息的bitmap压缩效果越好

## 9. 分布式锁

### 9.1 分布式锁应该具备哪些条件

### 9.2 分布式锁的常见实现方式有哪些

### 9.3 如何自己实现一个分布式锁

### 9.4 主从集群的锁丢失问题是什么

# 第06章_分布式基础

## 1. 基础知识

### 1.1 什么是CAP理论和BASE理论

### 1.2 什么是Paxos算法和Raft算法

### 1.3 什么是Gossip协议

Gossip协议是一种允许在分布式系统中共享状态的**去中心化通信协议**，通过这种通信协议，我们可以将信息传播给网络或集群中的所有成员。在 Gossip 协议下，没有所谓的中心节点，每个节点周期性地随机找一个节点互相同步彼此的信息，理论上来说，各个节点的状态最终会保持一致。

> Redis Cluster 就是基于 Gossip 协议来实现集群中各个节点数据的最终一致性。

Gossip协议中有两种消息传播模式：

- 反熵（Anti-Entropy）：会传播节点的所有数据
- 谣言传播（Rumor-Mongering）：只会传播节点新增的数据。比较适合节点数量比较多或者节点动态变化的场景。

**Gossip协议的优势**：

1. 相比于其他分布式协议/算法来说，Gossip 协议理解起来非常简单。
2. 能够容忍网络上节点随意地增加或者减少、宕机或者重启，因为 Gossip 协议下这些节点都是平等的，去中心化的。新增加或者重启的节点在理想情况下最终是一定会和其他节点的状态达到一致。
3. 速度相对较快。节点数量比较多的情况下，扩散速度比一个主节点向其他节点传播信息要更快。

**Gossip协议的缺陷**:

1. 消息需要通过多个传播的轮次才能传播到整个网络中，因此，必然会出现各节点状态不一致的情况。毕竟，Gossip 协议强调的是最终一致，至于达到各个节点的状态一致需要多长时间，谁也无从得知。
2. 由于拜占庭将军问题，不允许存在恶意节点。
3. 可能会出现消息冗余的问题。由于消息传播的随机性，同一个节点可能会重复收到相同的消息。

### 1.4 如何设计分布式ID

一个最基本的分布式 ID 需要满足下面这些要求：

- **全局唯一**
- **高性能**：分布式 ID 的生成速度要快，对本地资源消耗要小。
- **高可用**：生成分布式 ID 的服务要保证可用性无限接近于 100%。

除了这些之外，一个比较好的分布式 ID 还应保证：

- **安全**：ID 中不包含敏感信息。
- **有序递增**：如果要把 ID 存放在数据库的话，ID 的有序性可以提升数据库写入速度。并且，很多时候 ，我们还很有可能会直接通过 ID 来进行排序。
- **有具体的业务含义**：生成的 ID 如果能有具体的业务含义，可以让定位问题以及开发更透明化（通过 ID 就能确定是哪个业务）。
- **独立部署**：也就是分布式系统单独有一个发号器服务，专门用来生成分布式 ID。这样生成 ID 的服务就可以和业务相关的服务解耦。不过，这样同样带来了网络调用消耗增加的问题。总的来说，如果需要用到分布式 ID 的场景比较多的话，独立部署的发号器服务还是很有必要的。

通常情况下，我们会使用**雪花算法**来生成分布式ID。雪花算法（Snowflake Algorithm）由Twitter公司提出，它能够在分布式系统中生成**全局的唯一ID**，并且在同一个节点的表中能保证主键的**有序性**。

雪花算法生成的ID是一个64位的整数，由以下几个部分组成：

1. 符号位：1bit，正数是0，负数是1。一般id都是正数，所以该位通常都是0
2. 时间戳：41bit，精确到毫秒级
3. 节点ID：10bit，用于标识分布式系统中的不同节点
4. 序列号：12bit，表示在同一毫秒内生成的不同ID的序号，从0开始自增

**注意：雪花算法生成的数，需要使用Long或者String类型保存**

> 在实际项目中，我们一般也会对 Snowflake 算法进行改造，最常见的就是在 Snowflake 算法生成的 ID 中加入业务类型信息。

### 1.5 什么是负载均衡

### 1.8 什么是CDN

**CDN**全称是Content Delivery Network，即**内容分发网络**，也就是将**静态资源**分发到多个不同的地方以实现**就近访问**，进而加快静态资源的访问速度，减轻服务器以及带宽的负担。一般像阿里云、腾讯云等云厂商都会提供开箱即用的CDN服务。

静态资源缓存到CDN节点中有以下方式：

- 可以通过**预热**的方式将源站的资源同步到CDN节点中。这样的话，用户首次请求资源可以直接从CDN节点中取，无需回源。
- 如果不预热的话，那么访问的资源可能不在CDN节点中，这个时候CDN节点就会请求源站获取资源，这个过程称为**回源**。
- 如果资源有更新的话，可以对其**刷新**，也就是删除CDN节点上缓存的旧资源，并强制CDN节点回源获取最新资源。

> **命中率**和**回源率**是衡量CDN服务质量的两个重要指标。命中率越高越好，回源率越低越好。

找到最合适的CDN节点，主要是通过GSLB（Global Server Load Balance，全局负载均衡），具体流程如下：

1. 浏览器向 DNS 服务器发送域名请求；
2. DNS 服务器根据 CNAME( Canonical Name ) 别名记录向 GSLB 发送请求；
3. GSLB 返回性能最好（通常距离请求地址最近）的 CDN 节点的地址给浏览器；
4. 浏览器直接访问指定的 CDN 节点。

如果我们的资源被其他用户或者网站非法盗刷的话，将会是一笔不小的开支。解决这个问题最简单的办法就是设置 **Referer 防盗链**，具体来说就是根据 HTTP 请求头里面的 Referer 字段对请求进行限制。我们可以通过 Referer 字段获取到当前请求页面的来源页面的网站地址，这样我们就能确定请求是否来自合法的网站。CDN 服务提供商几乎都提供了这种比较基础的**防盗链机制**。

## 2. API网关

### 2.1 API网关的作用是什么

微服务背景下，一个系统被拆分为多个服务，但是像安全认证、流量控制、日志、监控等功能是每个服务都需要的，没有API网关的话，我们就需要在每个服务中单独实现，这使得我们做了很多重复的事情。

API网关最主要的作用是**请求转发**和**请求过滤**，常见的API网关有Spring Cloud Gateway。

### 2.2 Gateway的工作流程是怎样的

### 2.3 Gateway中路由和断言是什么关系

- 一个路由规则可以包含多个断言
- 如果一个路由规则中有多个断言，则需要同时满足才能匹配
- 如果一个请求可以匹配多个路由，则映射第一个匹配成功的路由

### 2.4 Gateway如何实现动态路由

一般是通过Nacos配置中心，动态修改配置，就能动态修改路由。

### 2.5 Gateway支持限流吗

从 Sentinel 1.6.0 版本开始，Sentinel 引入了 Spring Cloud Gateway 的适配模块，可以提供两种资源维度的限流：route 维度和自定义 API 维度。也就是说，Spring Cloud Gateway 可以结合 Sentinel 实现更强大的网关流量控制。



## 3. RPC

### 3.1 什么是RPC

**RPC（Remote Procedure Call）** 即远程过程调用。

**为什么要 RPC ？** 因为，两个不同的服务器上的服务提供的方法不在一个内存空间，所以，需要通过网络编程才能传递方法调用所需要的参数。并且，方法调用的结果也需要通过网络编程来接收。但是，如果我们自己手动网络编程来实现这个调用过程的话工作量是非常大的，因为我们需要考虑底层传输方式、序列化方式等等方面。

> 总结：**RPC 的出现就是为了让我们调用远程方法像调用本地方法一样简单**

### 3.2 RPC的底层原理是什么

整个 RPC 的核心功能是由下面 5 个部分实现的：

1. **客户端（服务消费端）**：调用远程方法的一端。
2. **客户端 Stub（桩）**：这其实就是一个代理类。代理类主要做的事情很简单，就是把你调用方法、类、方法参数等信息传递到服务端。
3. **网络传输**：网络传输就是把你调用的方法的信息（比如参数）传输到服务端，然后服务端执行完之后再把返回结果通过网络传输传输回来。网络传输的实现方式有很多种，比如最基本的 Socket ，或者性能以及封装更加优秀的 Netty（推荐）。
4. **服务端 Stub（桩）**：这个桩就不是代理类了。这里的服务端 Stub 实际指的就是接收到客户端执行方法的请求后，去执行对应的方法然后返回结果给客户端的类。
5. **服务端（服务提供端）**：提供远程方法的一端。

![image-20240318141736809](images/image-20240318141736809.png)

RPC底层原理如下：

1. 服务消费端（client）以本地调用的方式调用远程服务；
2. 客户端 Stub（client stub） 接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体（序列化）：`RpcRequest`；
3. 客户端 Stub（client stub） 找到远程服务的地址，并将消息发送到服务提供端；
4. 服务端 Stub（桩）收到消息将消息反序列化为 Java 对象: `RpcRequest`；
5. 服务端 Stub（桩）根据`RpcRequest`中的类、方法、方法参数等信息调用本地的方法；
6. 服务端 Stub（桩）得到方法执行结果并将组装成能够进行网络传输的消息体：`RpcResponse`（序列化）发送至消费方；
7. 客户端 Stub（client stub）接收到消息并将消息反序列化为 Java 对象:`RpcResponse` ，这样也就得到了最终结果。

### 3.3 常用的RPC框架有哪些

RPC框架指的是可以让客户端直接调用服务端方法，就像调用本地方法一样简单的框架，比如下面介绍的 **Dubbo、gRPC**。如果需要和 HTTP 协议打交道，解析和封装 HTTP 请求和响应，这类框架并不能算是“RPC 框架”，比如 **OpenFeign**。

**Dubbo**

Dubbo 是由阿里开源，后来加入了 Apache，它是一款微服务框架，为大规模微服务实践提供高性能 RPC 通信、流量治理、可观测性等解决方案，涵盖 Java、Golang 等多种语言 SDK 实现。

Dubbo 提供了从服务定义、服务发现、服务通信到流量管控等几乎所有的服务治理能力，支持 Triple 协议（基于 HTTP/2 之上定义的下一代 RPC 通信协议）、应用级服务发现、Dubbo Mesh （Dubbo3 赋予了很多云原生友好的新特性）等特性。

**gRPC**

gRPC 是 Google 开源的一个高性能、通用的 RPC 框架，它主要面向移动应用开发并基于 HTTP/2 协议标准而设计（支持双向流、消息头压缩等功能，更加节省带宽），基于 ProtoBuf 序列化协议开发，并且支持众多开发语言。

不过，gRPC 的设计导致其几乎没有服务治理能力。如果你想要解决这个问题的话，就需要依赖其他组件比如腾讯的 PolarisMesh（北极星）了。

### 3.4 有了HTTP协议，为什么还要有RPC

HTTP是一种应用层协议，而RPC本身并不是一种协议，而是一种调用方式。RPC和主流的HTTP/1.1协议主要有以下区别：

- HTTP一般是通过DNS来进行服务发现；而RPC一般会有专门的中间服务来保存服务名和IP信息
- HTTP/1.1默认在建立底层 TCP 连接之后会一直保持这个连接（**keep alive**），之后的请求和响应都会复用这条连接；而RPC一般会再建个 **TCP连接池**，在请求量大的时候，建立多条连接放在池内，便于复用
- HTTP/1.1的Header中的信息十分冗余，导致请求头很大，传输效率低；而RPC则采用体积更小的 Protobuf 或其他序列化协议去保存结构体数据，因此**性能更高**

**总结**：由于HTTP/2.0是2015年才出来的，所以在早期，很多公司由于RPC的**性能更高**，选择使用RPC而非HTTP/1.1。但是HTTP/2.0出来后，做了很多改进，所以**HTTP/2.0的性能比RPC还要高**，因此像现在的RPC框架**gRPC**，其底层也是基于HTTP/2.0的。

## 4. 分布式事务



## 5. ZooKeeper

### 5.1 简单介绍下ZooKeeper

### 5.2 ZooKeeper的Leader选举过程

### 5.3 ZooKeeper集群为什么最好是奇数台

### 5.4 ZooKeeper集群是否会发生脑裂

### 5.5 ZAB协议是什么

### 5.6 如何基于ZooKeeper实现分布式锁



# 第07章_消息队列

## 1. RabbitMQ

### 1.1 RabbitMQ中交换机有哪些类型

### 1.2 AMQP协议是什么

AMQP，即 Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准 **高级消息队列协议**（二进制应用层协议），是应用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件同产品，不同的开发语言等条件的限制。

RabbitMQ 就是 AMQP 协议的 `Erlang` 的实现(当然 RabbitMQ 还支持 `STOMP2`、 `MQTT3` 等协议 ) 。AMQP 的模型架构和 RabbitMQ 的模型架构是一样的，生产者将消息发送给交换器，交换器和队列绑定。

> RabbitMQ 中的交换器、交换器类型、队列、绑定、路由键等都是遵循的 AMQP 协议中相应的概念。

**AMQP协议的三层**：

- **Module Layer**: 协议最高层，主要定义了一些客户端调用的命令，客户端可以用这些命令实现自己的业务逻辑。
- **Session Layer**: 中间层，主要负责客户端命令发送给服务器，再将服务端应答返回客户端，提供可靠性同步机制和错误处理。
- **TransportLayer**: 最底层，主要传输二进制数据流，提供帧的处理、信道服用、错误检测和数据表示等。

**AMQP 模型的三大组件**：

- **交换器 (Exchange)**：消息代理服务器中用于把消息路由到队列的组件。
- **队列 (Queue)**：用来存储消息的数据结构。
- **绑定 (Binding)**：一套规则，告知交换器消息应该将消息投递给哪个队列。

### 1.3 说说RabbitMQ的工作模型

### 1.4 死信队列是什么，死信是如何产生的

DLX，全称为 `Dead-Letter-Exchange`，死信交换器。当消息在一个队列中变成死信 (`dead message`) 之后，如果该队列设置了对应的DLX，那么该消息就能被重新发送到这个DLX中，然后再由DLX将消息路由到对应的队列中（称之为死信队列）。

**产生死信的情况**：

- 消息TTL过期(TTL即Time To Live，生存时间)
- 队列达到最大长度（即队列已满）
- 消息被拒绝(否定确认)，即`channel.basicReject()`或`channel.basicNack()`，并且没有重新入队(`requeue=false`)

### 1.5 优先级队列是什么

### 1.6 延迟队列是什么

延迟队列用于存放需要在指定时间被处理的消息（延迟消息）。例如，让订单在十分钟之内未支付则自动取消，就可以使用延迟队列来实现。

AMQP协议以及RabbitMQ本身没有直接支持延迟队列的功能，但是我们可以通过**基于TTL的死信机制**来实现延迟队列。也就是给消息设置TTL、或给队列设置TTL，这样该队列就是一个延迟队列，当队列中的消息达到超时时间后，就变成死信，转发给死信交换机处理。

注意，上述方式实现的延迟队列会有一个问题：如果第一个消息的TTL很长，而第二个消息的TTL很短，那么第二个消息并不会优先被丢弃（成为死信），而是会等到第一个消息被丢弃后，才会立即丢弃。（当然，如果是基于队列的TTL，而不是基于消息的TTL，就不会有这一问题）。

因此，RabbitMQ还提供了**基于插件**实现的延迟队列。延迟队列插件直接在交换机处就实现延迟，然后再发送给队列，让消费者进行消费即可，流程上简单得多。

### 1.7 RabbitMQ有哪些工作模式

### 1.8 生产者和消费者是怎么传输消息的

信道（Channel）是生产者、消费者与 RabbitMQ 通信的渠道，发送和接收消息都是通过信道进行的。信道是建立在 TCP 连接上的虚拟连接，每条 TCP 连接上的信道数量没有限制。就是说 RabbitMQ 在一条 TCP 连接上建立成百上千个信道来达到多个线程处理，这个 TCP 被多个线程共享，每个信道在 RabbitMQ 都有唯一的 ID，保证了信道私有性，每个信道对应一个线程使用。**Channel是轻量级的，能大幅减少操作系统建立TCP连接的开销**。

### 1.9 如何保证消息的可靠性

消息的可靠性投递，指的就是要保证消息投递过程中每一个环节都要成功。所以要保证可靠性，必然会牺牲一点性能。保证消息的完全可靠投递，有以下四个环节：

1. 保证消息从生产者正确投递到交换机。一般使用消息的Confirm模式来保证该环节的可靠性。
2. 保证消息从交换机正确路由到队列。一般使用消息的Returns模式，或者使用备用交换机，来保证该环节的可靠性。
3. 保证消息在队列中持久存储。一般让交换机、队列、消息都进行持久化，就能保证该环节的可靠性。
4. 保证消息从队列中正确被消费者消费。一般使用消息的手动确认，就能保证该环节的可靠性。

### 1.10 如何保证RabbitMQ的高可用

## 2. Kafka

### 2.1 Kafka如何保证消息顺序消费

### 2.2 Kafka如何防止消息丢失

### 2.3 Kafka如何防止消息重复消费

### 2.4 Kafka如何防止消息积压

### 2.5 Kafka为何性能极高

### 2.6 说说Kafka的核心概念

### 2.7 ZooKeeper和Kafka的关系

### 2.8 Kafka的多副本机制是什么

### 2.9 说一说Kafka的重试机制



# 第08章_JVM

## 1. 运行时数据区

### 1.1 介绍一下JVM的运行时数据区

### 1.2 创建对象的过程是怎样的

###  1.3 对象的内存布局是怎样的

### 1.4 对象的访问定位方式是什么

### 1.5 对象分配的原则有哪些

### 1.6 什么是空间分配担保

### 1.7 HotSpot为什么要分新生代和老年代

## 2. 类加载器子系统

### 2.1 介绍一下类的加载过程

### 2.2 类加载器有哪些

### 2.3 什么是双亲委派模型

## 3. 执行引擎

### 3.1 标记算法有哪些

### 3.2 垃圾收集算法有哪些

### 3.3 Java的引用类型有哪些

### 3.4 垃圾收集器有哪些

### 3.5 G1的工作流程是怎样的

### 3.6 什么是解释器和JIT编译器

### 3.7 什么是AOT



# 第09章_JUC

## 1. 基础知识

### 1.1 创建线程的方式有哪些

### 1.2 可以直接调用Thread类的run()方法启动线程吗

### 1.3 说说线程的生命周期

### 1.4 synchronized和ReentrantLock有什么区别

### 1.5 等待唤醒机制怎么实现

### 1.6 sleep()和wait()有什么区别

### 1.7 synchronized锁升级是什么

### 1.8 如何实现子线程先执行，主线程再执行

调用Thread类的`join()`方法

### 1.9 如果不使用锁，如何保证线程安全

原子类、ThreadLocal、不可变对象（final修饰）等

## 2. 锁

### 2.1 什么是悲观锁和乐观锁

### 2.2 什么是读写锁

### 2.3 读写锁的锁降级是什么

### 2.4 什么是邮戳锁

## 3. JMM

### 3.1 什么是JMM

### 3.2 什么是happens-before原则

### 3.3 如何保证原子性、可见性、有序性

### 3.4 volatile有什么特性，底层是怎么实现的

## 4. 原子类

### 4.1 什么是CAS

### 4.2 CAS有什么缺点

### 4.3 整型原子类的底层原理

### 4.4 LongAdder解决了什么问题，它是如何实现的？

## 5. AQS和并发容器

### 5.1 什么是AQS

### 5.2 说说常用的同步工具类及其原理

### 5.3 有哪些并发容器，底层原理是什么

## 6. 线程池

### 6.1 什么是线程池

### 6.2 为什么不推荐使用Executors的内置线程池

### 6.3 线程池的常见参数有哪些

### 6.4 线程池的拒绝策略有哪些

### 6.5 如何设定线程池的大小

### 6.6 线程池的API有哪些

## 7. CompletableFuture

### 7.1 Future和CompletableFuture的区别

### 7.2 CompletableFuture的常用API有哪些

### 7.3 Callable和Future有什么关系

## 8. ThreadLocal

### 8.1 什么是ThreadLocal

### 8.2 ThreadLocal的底层原理

### 8.3 ThreadLocal为什么会有内存泄漏问题



# 第10章_JavaSE

## 1. 基础知识

### 1.1 为什么Java代码可以实现一次编写、到处运行

### 1.2 一个Java文件里可以有多个类吗（不含内部类）

### 1.3 什么是泛型擦除

### 1.4 说一说你对Java反射机制的理解

## 2. 包装类

### 2.1 包装类的缓存机制是什么

### 2.2 自动装箱和自动拆箱是什么

### 2.3 如何对Integer和Double类型判断相等

转化为基本数据类型，再进行比较

## 3. 面向对象编程

### 3.1 成员变量和局部变量的区别

### 3.2 方法重写有哪些要求

### 3.3 可变长参数有哪些特点

### 3.4 面向对象的三大特征是什么

### 3.5 接口和抽象类有什么共同点和区别

共同点：

- 都不能被实例化
- 都可以包含抽象方法
- 都可以有默认实现的方法

区别：

- 接口主要用于对类的行为进行约束，是一种规范；而抽象类主要用于代码复用，强调的是所属关系
- 一个类只能继承一个类，但可以实现多个接口

### 3.6 引用拷贝、浅拷贝、深拷贝的区别

![image-20240508153514263](./images/image-20240508153514263.png)

### 3.7 Object类的常用方法有哪些

### 3.8 为什么重写equals()时还必须重写hashCode()

因为要遵守规定：两个相等的对象的hashCode值必须相等。

## 4. String

### 4.1 String、StringBuilder、StringBuffer的区别

### 4.2 String为什么是不可变的

### 4.3 创建字符串时，new和`""`推荐使用哪种方式

### 4.4 两个字符串拼接的底层是如何实现的

### 4.5 String的intern()方法的作用

## 5. 异常处理

### 5.1 说一说Java的异常机制

### 5.2 finally是必然执行的吗

### 5.3 在finally中return会发生什么

在finally中进行return或throw，会导致try块和catch块中的return和throw失效，最终执行的是finally中的。

## 6. IO

### 6.1 什么是序列化和反序列化

### 6.2 Serializable接口为什么需要定义serialVersionUID变量

### 6.3 介绍一下Java中的IO流

### 6.4 UNIX的五大IO模型

### 6.5 Java的三大IO模型

## 7. 集合

### 7.1 介绍一下HashMap底层的实现原理

### 7.2 如何得到一个线程安全的Map

### 7.3 请介绍LinkedHashMap的底层原理

### 7.4 请介绍TreeMap的底层原理

### 7.5 请介绍ArrayList的底层原理




























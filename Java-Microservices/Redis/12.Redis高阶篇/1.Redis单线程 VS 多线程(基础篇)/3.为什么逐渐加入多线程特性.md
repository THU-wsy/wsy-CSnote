# 为什么逐渐加入多线程特性

### 单线程也有苦恼，举个例子

正常情况下使用 del 指令可以很快的删除数据，而当被删除的 key 是一个非常大的对象时，例如key包含了成千上万个元素的 hash 集合时，那么 del 指令就会造成 Redis 主线程卡顿。

$\textcolor{red}{\large 这就是redis3.x单线程时代最经典的故障，大key删除的头疼问题，}$由于redis是单线程的，del bigKey .....

等待很久这个线程才会释放，类似加了一个synchronized锁，你可以想象高并发下，程序堵成什么样子?

### 如何解决

- 使用惰性删除可以有效的解决性能问题

- 案例

  比如当我(Redis)需要删除一个很大的数据时，因为是单线程原子命令操作，这就会导致 Redis 服务卡顿，于是在 Redis 4.0 中就新增了多线程的模块，当然此版本中的多线程主要是为了解决删除数据效率比较低的问题的。

  | unlink key            |
  | --------------------- |
  | flushdb async         |
  | flushall async        |
  | 把删除工作交给了后台的子线程异步删除数据了 |

  因为Redis是单个主线程处理，redis之父antirez一直强调"Lazy Redis is better Redis"。

  而lazy free的本质就是把某些cost(主要时间复杂度，占用主线程cpu时间片)较高删除操作，从redis主线程剥离让bio子线程来处理，极大地减少主线阻塞时间。从而减少删除导致性能和稳定性问题。

- 在Redis4.0就引入了多个线程来实现数据的异步惰性删除等功能但是其处理读写请求的仍然只有一个线程，所以仍然算是狭义上的单线程。









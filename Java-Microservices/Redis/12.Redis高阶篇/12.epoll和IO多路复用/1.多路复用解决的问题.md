### 多路复用要解决的问题

<font color = 'blue'>并发多客户端连接</font>，在多路复用之前最简单和典型的方案：<font color = 'red'> 同步阻塞网络IO模型</font>

这种模式的特点就是<font color = 'red'>用一个进程来处理一个网络连接(一个用户请求)</font>，比如一段典型的示例代码如下：直接调用 recv 函数从一个 socket 上读取数据。

int main(){

...

recv(sock, ...) // <font color = 'blue'>从用户角度来看非常简单，一个recv一用，要接收的数据就到我们手里了。</font>

}

我们来总结一下这种方式:

优点就是这种方式非常容易让人理解，写起代码来非常的自然，符合人的直线型思维。

<font color = 'red'>缺点就是性能差，每个用户请求到来都得占用一个进程来处理，来一个请求就要分配一个进程跟进处理</font>，类似一个学生配一个老师，一位忠者配一个医生，可能吗? 进程是一个很笨重的东西。一台服务器上创建不了多少个进程。

### 结论

进程在 Linux 上是一个开销不小的家伙，先不说创建，光是上下文切换一次就得几个微秒。所以为了高效地对海量用户提供服务，<font color = 'red'>必须要让一个进程能同时处理很多个 tcp 连接才行</font>。现在假设一个进程保持了 10000 条连接，那么如何发现哪条连接上有数据可读了哪条连接可写了 ?

我们当然可以采用循环遍历的方式来发现 IO 事件，但这种方式太低级了。

我们希望有一种更高效的机制，在很多连接中的某条上有 IO 事件发生的时候直接快速把它找出来。

其实这个事情 Linux 操作系统已经替我们都做好了，它就是我们所熟知的 IO 多路复用机制。<font color = 'red'>这里的复用指的就是对进程的复用。</font>










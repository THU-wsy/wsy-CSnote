
# 第1章 计算机系统概论

## 1.1 计算机的发展历程

- 计算机发展历程：
    > 第一代计算机——电子管时代。第一台电子数字计算机ENIAC。电子管也称真空管。
    > 第二代计算机——晶体管时代。
    > 第三代计算机——中小规模集成电路时代。
    > 第四代计算机——大规模集成电路时代。
    > 第五代计算机——超大规模集成电路时代。

- 早期计算机的更新换代主要集中体现在组成计算机基本电路的元器件(电子管、晶体管、集成电路)上。微型计算机的发展很大程度上取决于微处理器的发展，而微处理器的发展又依赖于芯片集成度和处理器主频的提高。
- 摩尔定律：微芯片上集成的晶体管数目每3年翻两番。由于受物理极限的制约，Moore定律不能永远生效。

## 1.2 计算机系统简介

计算机系统由硬件和软件两大部分组成，完整的计算机系统应包括配套的硬件设备和软件系统，软件和硬件在逻辑功能上是等价的。软件又分为系统软件和应用软件，系统软件主要有操作系统(OS)、语言处理程序(如汇编程序、编译程序、解释程序)、服务程序(如诊断程序、调试程序、连接程序)、数据库管理系统(DBMS)、标准程序库、分布式软件系统、网络软件系统等；应用软件有科学计算程序、数据处理程序、过程控制程序、事务管理程序等。

### 计算机硬件

1. 冯·诺依曼计算机的特点(存储程序的思想：将程序送入主存，由计算机逐条执行)：
	- 采用存储程序的原理，基本工作方式是控制流驱动方式
	-   计算机硬件系统由运算器、存储器、控制器、输入设备和输出设备五大部件组成
	-   指令和数据以同等地位存放于存储器内，并可按地址寻访(CPU区分它们的依据是指令周期的不同阶段)
	-   指令和数据均用二进制数表示
	-   指令由操作码和地址码组成。操作码指出操作的类型，地址码指出操作数的地址。
	-   指令在存储器内按顺序存放
	-   机器以运算器为中心

2. 现代计算机以存储器为中心。运算器和控制器合起来统称为中央处理器CPU，输入设备和输出设备简称I/O设备，所以现代计算机由三大部分CPU、I/O设备和主存储器组成，其中==CPU和主存储器==合起来又可称为==主机==，除主机外的其他硬件装置(外存、I/O设备等)统称为外部设备，简称外设。

3. 五大部件

	- 存储器
		
		存储器分为主存储器(主存、内存)和辅助存储器(辅存，外存)，CPU能够直接访问的是主存储器，而辅助存储器中的信息必须调入主存后才能被CPU访问。
		
		>主存主要包含存储体、MAR、MDR以及时序控制逻辑等。存储体由许多存储单元组成，每个存储单元包含若干存储元件(每个存储元件存储一个bit)，所以存储单元可以存储一串二进制代码，称这串代码为存储字，称这串代码的位数为存储字长。MAR是存储器地址寄存器，用来存放欲访问的存储单元的地址，其位数对应存储单元的个数(如MAR为10位，则有$2^{10}$个存储单元)。MDR是存储器数据寄存器，用来存放从存储体某单元取出的代码或者准备往某存储单元存入的代码，其位数与存储字长相等。
		>
		>主存的工作方式是按存储单元的地址进行存取，这种存取方式称为按地址存取方式，即按地址访问存储器(访存)
		>
		> MAR和MDR虽然是存储器的一部分，但现代计算机中MAR和MDR存在于CPU中，除此之外，Cache也存在于CPU中
	
	- 运算器
		
		运算器最少包括3个寄存器(累加器ACC、乘商寄存器MQ、操作数寄存器X)和一个算术逻辑单元(ALU)。运算器内还有程序状态寄存器(PSW)，也称标志寄存器，用于存放ALU运算得到的一些标志信息或处理机的状态信息。
		
		> 加法：ACC存放被加数及和，X存放加数
		> 减法：ACC存放被减数及差，X存放减数
		> 乘法：ACC存放乘积高位，MQ存放乘数及乘积低位，X存放被乘数
		> 除法：ACC存放被除数及余数，MQ存放商，X存放除数
		
	- 控制器
		
		控制器由控制单元(CU)、程序计数器(PC)和指令寄存器(IR)组成。
		
      > PC用来存放当前欲执行指令的地址，它与主存的MAR之间有一条直接通路，且具有自动加1的功能，即可自动形成下一条指令的地址，PC的位数与MAR的位数相同
	   >
	   >IR用来存放当前的指令，IR的内容来自主存的MDR。指令中的操作码OP(IR)送至CU，用来分析指令，指令中的地址码Ad(IR)作为操作数的地址送往MAR，用以取操作数
	   >
	   >CU用来分析当前指令所需完成的操作，并发出各种微操作命令序列，用以控制所有被控对象
	   >
	   >完成一条指令的过程分为取指阶段(PC)、分析阶段(IR)、执行阶段(CU)

	-  输入设备
	-  输出设备

4. 计算机的工作过程

![](/zzimages/20230326215756.png)
		
![](/zzimages/20230326215822.png)

### 计算机系统的层次结构

五级计算机系统的层次结构：
> 虚拟机器M4(高级语言机器) 
> 虚拟机器M3(汇编语言机器)
> 虚拟机器M2(操作系统机器)
> 传统机器M1(机器语言机器)
> 微程序机器M0(微指令系统)

注1：将高级语言程序翻译成机器语言程序的软件称为翻译程序，分为以下三类: 
> 汇编程序(汇编器)：将汇编语言程序翻译成机器语言程序
> 解释程序(解释器)：将源程序中的语句按执行顺序逐条翻译成机器指令并立即执行
> 编译程序(编译器)：将高级语言程序翻译成汇编语言程序

注2 ：从源程序到可执行文件的翻译过程如下：

> 预处理阶段：预处理器(cpp)对源程序中以字符#开头的命令进行处理，例如将#include命令后面的.h文件内容插入程序文件。输出结果是一个以.i为扩展名的源文件hello.i
> 
> 编译阶段：编译器(ccl)对预处理后的源程序进行编译，生成一个汇编语言源程序hello.s。汇编语言源程序中的每条语句都以一种文本格式描述了一条低级机器语言指令。
> 
> 汇编阶段：汇编器(as)将hello.s翻译成机器语言指令，把这些指令打包成一个称为可重定位目标文件的hello.o，它是一种二进制文件，因此用文本编辑器打开会显示乱码。
> 
> 链接阶段：链接器(ld)将多个可重定位目标文件和标准库函数合并为一个可执行目标文件，或简称可执行文件。本例中，链接器将hello.o和标准库函数printf所在的可重定位目标模块printf.o合并，生成可执行文件hello。最终生成的可执行文件被保存在磁盘上。

### 计算机组成和计算机体系结构

计算机体系结构是指那些能够被程序员所见到的计算机系统的属性，即概念性的结构与功能特性，比如指令集、数据类型、存储器寻址技术、I/O机理等，大都属于抽象的属性。计算机组成是指如何实现计算机体系结构所体现的属性，它包含了许多对程序员来说是透明的硬件细节，比如如何取指令、分析指令、取操作数、运算、送结果等都属于计算机组成问题。

## 1.3 计算机的性能指标

### 1. 字长

- 某“64位机器”中64指的就是字长，也称机器字长，它是CPU一次能处理数据的位数，通常等于CPU内部用于整数运算的运算器位数和通用寄存器宽度。注意字和字长概念不同，字用来表示被处理信息的单位，用来度量数据类型的宽度，比如x86机器中将一个字定义为16位
- 指令字长是指一个指令字中包含的二进制代码的位数(指令字长一般是存储字长的整数倍)
- 存储字长是指一个存储单元存储的二进制代码的位数

### 2. 数据通路带宽

数据通路带宽是指数据总线一次所能并行传送信息的位数，这里指的是外部数据总线的宽度，与CPU内部的数据总线宽度(内部寄存器的大小)有可能不同。

### 3. 存储容量

$$
存储容量 = 存储单元个数 \times 存储字长
$$
如MAR为16位，可称为$64K$内存，若MDR为32位，表示主存容量为$64K \times 32$位，现代计算机中常以字节数描述容量大小，即为$256KB$。

### 4. 运算速度

- 吞吐量：系统在单位时间内处理请求的数量
	响应时间：从用户向计算机发送一个请求到系统对该请求作出响应并获得所需结果的等待时间
- 主频(CPU时钟频率)：机器内部主时钟的频率，单位为Hz
	CPU时钟周期：主频的倒数(是CPU中最小的时间单位)
- CPI：执行一条指令所需的时钟周期数
- CPU执行时间：运行一个程序所花费的时间
$$CPU执行时间=\frac{CPU时钟周期数}{主频}=\frac{指令条数\times CPI}{主频}$$
- IPS：每秒执行多少条指令，分为kIPS和MIPS
$$IPS=\frac{主频}{平均CPI}$$
- FLOPS：每秒执行多少次浮点运算，分为kFLOPS、MFLOPS、GFLOPS、TFLOPS等
	注意在描述速率、频率时，k、M、G、T分别表示$10^3,10^6,10^9,10^{12}$，而在描述存储容量、文件大小时，K、M、G、T分别表示$2^{10},2^{20},2^{30},2^{40}$ (更大的有P、E、Z)

### 5. 基准程序

基准程序是专门用来进行性能评价的一组程序。

注： 几个专业术语：

> 系列机：具有基本相同的体系结构，使用相同基本指令系统的多个不同型号的计算机组成的一个产品系列
> 
> 兼容：指软件或硬件的通用性
> 
> 软件可移植性：指把使用在某个系列计算机中的软件直接或进行很少的修改就能运行在另一个系列计算机中的可能性
> 
> 固件：将程序固化在ROM中组成的部件称为固件，它是一种具有软件特性的硬件，执行速度快于软件，灵活性优于硬件

# 第2章 计算机的运算方法

## 2.1 无符号数和有符号数

>原码：进行加减运算时比较麻烦，当两个操作数符号不同作加法时，要判断绝对值大小确定符号
>
>补码：由y的补码连同符号位在内，每位取反，末位加1，可以得到-y的补码
>
>反码
>
>移码=偏置值+真值，一般取偏置值为$2^{n−1}$，于是$[x]_{移}=x+2^{n-1}$，注意移码只能表示整数
> - 如果偏置值为$2^{n - 1}$，则移码其实等同于补码的最高位(符号位)取反，所以移码表示中零也是唯一的
> - 如果偏置值为$2^{n - 1}$，则可表示的最小真值的移码为全0，所以用移码可以方便地判断数的大小
> - IEEE中阶码规定用偏置值为$2^{n - 1} - 1$的移码表示

## 2.2 ALU电路

![](/zzimages/20230327165610.png)

- 一位全加器: 全加器(FA)是最基本的加法单元，有加数$A_i、B_i$与低位传来的进位$C_{i−1}$ 共三个输入，有本位和$S_i$与向高位的进位$C_i$共两个输出。

	> 和表达式：$S_i = A_i\bigoplus B_i \bigoplus C_{i-1}$
	> 进位表达式：$C_i = A_iB_i+(A_i\bigoplus B_i)C_{i - 1}$
	> 称$A_iB_i$为进位产生函数，$A_i\bigoplus B_i$为进位传递函数
	
- 串行进位的并行加法器：n个全加器相连，其最长运算时间主要由进位信号的传递时间决定
- 并行进位的并行加法器：并行加法器中的进位信号同时产生，又称先行进位、跳跃进位
	> 根据逻辑运算可将$C_i$的表达式化作只依赖于$C_0$，而不依赖于其他$C_k$，从而实现先行进位。实现这一逻辑表达式的电路称为先行进位部件(CLA部件)。
	> 但位数越高，$C_i$的逻辑表达式越长。所以对于16位加法器，可以分成4组，组内为4位先行进位，组间串行进位，称之为单级先行进位加法器。也可以采用组内和组间都并行的进位方式，称之为两级先行进位加法器。
	
## 2.3 浮点数

### 1. 浮点数的一般形式

|阶符|阶码的数值部分|数符|尾数的数值部分|
|-|-|-|-|

当运算结果大于浮点数能表示的最大正数时称为正上溢，小于最小负数时称为负上溢，此时机器停止运算，进行中断溢出处理；当运算结果在0至浮点数能表示的最小正数时称为正下溢，在0至浮点数能表示的最大负数时称为负下溢，此时计算机将其当作机器零处理

规格化：
- 基数为2，规格化时，尾数算术左移一位，阶码减一，称为左规；尾数算术右移一位，阶码加一，称为右规(右规一般用于浮点数运算结果出现溢出时，比如双符号位为01或者10)。类似地，若基数为4，规格化时算术左(右)移两位，阶码减(加)一
- 用原码表示的规格化尾数：正数为0.1……的形式，所以最大值为0.11……1，最小值为0.10……0; 负数为1.1……的形式，所以最大值为1.10……0，最小值为1.11……1
	用补码表示的规格化尾数：正数为0.1……的形式，所以最大值为0.11……1，最小值为0.10……0; 负数为1.0……的形式，所以最大值为1.01……1，最小值为1.00……0
	一般来说，基数r越大，可表示的浮点数范围越大，个数越多，但精度反而下降。
- 当一个浮点数尾数为0时，不论阶码为何值；或者阶码等于或小于它所能表示的最小数时，不论其尾数为何值，机器都将该浮点数视作零，称为机器零

### 2. IEEE 754标准

![](/zzimages/20230327171022.png)

![](/zzimages/20230327171034.png)

![](/zzimages/20230327171041.png)

### 3. 强制类型转换

![](/zzimages/20230327171058.png)

## 2.4 移位运算

逻辑移位(无符号数的移位)：逻辑左移时，高位丢弃，低位添0；逻辑右移时，低位丢弃，高位添0

算术移位(有符号数的移位)：无论正数或负数，符号位始终不变，数值部分进行移位添补。对于正数，无论原码、反码、补码，算术移位时均添补0，而对于负数，添补规则如下：

> 原码：左移右移均添0
> 反码：左移右移均添1
> 补码：左移时低位添0，右移时高位添1

循环移位:

> 带进位标志位CF的循环移位(大循环)：数据位连同进位标志位一起移位
> 不带进位标志位的循环移位(小循环)：数据位中移出的位既移入进位标志位，又移入数据位

![](/zzimages/20230327171324.png)

## 2.5 加法与减法运算

$$[A+B]_{补} = [A]_{补} + [B]_{补} (\mod 2^{n + 1})$$

$$[A-B]_{补} = [A]_{补} + [-B]_{补} (\mod 2^{n + 1})$$
### 溢出判断

采用一位符号位，注意到只有正数+正数会发生上溢，负数+负数会发生下溢，所以设A的符号位为$A_s$，B的符号位为$B_s$，运算结果的符号位为$S_s$，则溢出逻辑表达式为$V=A_s B_s \overline{S_s}  + \overline{A_s } \overline{B_s } S_s.$ 若V=0，表示无溢出；若V=1，表示有溢出.

采用一位符号位根据数据位的进位情况判断溢出，若符号位的进位$C_s$与最高数位的进位$C_1$相同，则说明没有溢出，否则表示发生溢出。溢出逻辑表达式为$V=C_s\bigoplus C_1$，若V=0，表示无溢出；若V=1，表示有溢出.

采用双符号位。双符号位的补码又称模4补码或变形补码(单符号位补码称为模2补码)，符号位为00表示正数，11表示负数(但在存储时，计算机中只需一个符号位)。采用双符号位补码进行加减运算时，若运算结果的两位符号位相同，表示没有溢出，否则表示溢出，01表示正溢出，10表示负溢出(高位符号位代表真正的符号，低位符号位表示该数现在的符号，比如两个正数相加得到符号位为01，表示理应是一个正数，缺因上溢变成了一个负数)

### 程序状态字寄存器PSW

PSW中有几个标志位可用来区分有符号整数和无符号整数的运算结果

> 零标志ZF：运算结果为0则ZF=1，否则ZF=0. 不管对于无符号数还是有符号数运算，ZF都有意义
> 溢出标志OF：有符号整数运算发生溢出时OF=1，否则为0. 对于无符号数运算，OF没有意义
> 符号标志SF：表示运算结果的符号，结果为负则SF=1，否则为0. 对于无符号数运算，SF没有意义
> 进/借位标志CF：表示无符号整数运算时的进位/借位，判断是否发生溢出，加法时CF=1表示结果溢出(有进位)，减法时CF=1表示不够减(有借位)，而CF=0则表示没有进位和借位. 对于有符号数运算，CF没有意义

### 符号扩展

例如将4位二进制数扩展为8位二进制数

正整数：0 101 扩展为0 0000101
正小数：0 101 扩展为0 1010000

负整数：
> 原码：1 101 扩展为1 0000101
> 反码：1 010 扩展为1 1111010
> 补码：1 011 扩展为1 1111011

负小数：
> 原码：1 101扩展为1 1010000
> 反码：1 010扩展为1 0101111
> 补码：1 011扩展为1 0110000

## 2.6 乘法运算

![](/zzimages/20230327172637.png)

![](/zzimages/20230327172653.png)

## 2.7 除法运算

![](/zzimages/20230327172722.png)

![](/zzimages/20230327172729.png)

![](/zzimages/20230327172736.png)

## 2.8 数据的存储和排列

大端方式和小端方式：
> 大端方式按从最高有效字节到最低有效字节的顺序存储数据，即最高有效字节(MSB)放在低地址
> 小端方式按从最低有效字节到最高有效字节的顺序存储数据，即最低有效字节(LSB)放在低地址

边界对齐和边界不对齐方式：如果数据按边界对齐方式存储，则其存放的起始地址必须能被自身长度整除

![](/zzimages/20230327172907.png)

## 2.9 浮点数的加减运算

![](/zzimages/20230327172935.png)

## 2.10 校验码

### 奇偶校验码

![](/zzimages/20230327173015.png)

![](/zzimages/20230327173021.png)

偶校验的硬件实现：各信息位进行异或运算，得到的结果即为偶校验位

### 海明校验码

![](/zzimages/20230327173041.png)

![](/zzimages/20230327173046.png)

![](/zzimages/20230327173054.png)

- 有时，海明码校验位的位置设计可能相反，但做法类似：

![](/zzimages/20230327173222.png)
- 海明码拥有纠1位错，检2位错的能力(但检2位错需要加上全校验位)：

![](/zzimages/20230327173249.png)

### 循环冗余校验码(CRC码)

![](/zzimages/20230327173313.png)

![](/zzimages/20230327173322.png)

部分余数最高位为1则商1，否则商0(即模2除)；部分余数作减法采用模2减(等同于模2加)

![](/zzimages/20230327173400.png)

![](/zzimages/20230327173406.png)

![](/zzimages/20230327173413.png)

# 第3章 存储系统

## 3.1 存储器概述

### 1. 存储器的层次结构

![](/zzimages/20230328134701.png)

注：主存和Cache之间的数据调动对所有程序员均是透明的，而主存和辅存之间的数据调动对==应用程序员==是透明的

### 2. 存储器的分类

- 按层次(作用)分类：主存储器、辅助存储器、高速缓冲存储器
- 按存储介质分类：半导体存储器(主存、Cache)、磁表面存储器(磁盘、磁带)、磁芯存储器、光盘存储器(光盘)
- 按存取方式分类：
	> 随机存取存储器(RAM)：存储器的任何一个存储单元的内容都可以随机存取，存取时间与存储单元的物理位置无关。分为静态RAM和动态RAM
	> 
	> 只读存储器(ROM)：也支持随机访问，但存储器的内容只能随机读出而不能写入。事实上由ROM派生出的存储器也包含可反复重写的类型
	> 
	> 串行访问存储器：对存储单元进行读写操作时，需按其物理位置的先后顺序寻址。分为==顺序存取存储器(SAM)(如磁带)==和==直接存取存储器(DAM)(如磁盘、光盘)==。SAM读取一个存储单元所需时间取决于其物理位置，DAM既有随机存取特性又有顺序存取特性，先直接选取信息所在区域(如磁盘上的磁道)，然后按顺序方式存取。
	> 
	> 相联存储器：可以==按内容访问==的存储器(CAM)，按照内容检索到存储位置进行读写，如"快表"
	
- 按信息的可保存性分类：易失性存储器(断电后存储信息消失，==如RAM==)、非易失性存储器(==如ROM、磁表面存储器、光盘存储器==)；破坏性读出(信息被读出后，原存储信息被破坏，==如DRAM芯片==，读出数据后要进行重写)、非破坏性读出(==如SRAM芯片、磁盘、光盘==)

### 3. 存储器的性能指标

存储容量=存储字数$\times$存储字长
每位价格(位价)=总成本/总容量
存储速度：==数据传输率=数据的宽度/存取周期==
- 数据的宽度就是存储字长
- 存取时间$T_a$：存取时间是指从启动一次存储器操作到完成该操作所经历的时间，分为读出时间和写入时间
- 存取周期$T_m$：存取周期又称读写周期或访问周期，它是指存储器进行一次完整的读写操作所需的全部时间，即连续两次独立访问存储器操作(读或写操作)之间所需的最小时间间隔。通常存取周期大于存取时间，因为==存取周期等于存取时间加上恢复时间==，比如DRAM是破坏性读出，所以还需要一段较长的恢复内部状态的时间。
- 主存带宽$B_m$：即数据传输率，表示每秒从主存进出信息的最大数量，单位有字/秒，字节/秒(B/s)和位/秒(b/s)

## 3.2 主存储器

### 1. 主存储器(Main Memory,MM)的基本组成

- 半导体存储元件(DRAM芯片)：MOS管(作为通电开关)和电容(存储电荷，即存储二进制位0/1)
- 存储器芯片(DRAM芯片)的结构

![](/zzimages/20230328135447.png)

![](/zzimages/20230328135455.png)
- 寻址方式(现代计算机通常按字节编址，但寻址方式有多种)

![](/zzimages/20230328135518.png)

### 2. SRAM芯片和DRAM芯片

![](/zzimages/20230328135536.png)

![](/zzimages/20230328135545.png)

![](/zzimages/20230328135551.png)

### 3. 只读存储器ROM(结构简单，位密度比RAM高，具有非易失性)

- 掩模式只读存储器(MROM)：厂家在生产过程中直接写入信息，之后任何人无法重写，只能读出。可靠性高，集成度高，价格便宜，但灵活性差。
- 一次可编程只读存储器(PROM)：允许用户使用专门的设备(编程器)写入自己的程序，写入一次之后就不可更改
- 可擦除可编程只读存储器(EPROM)：允许用户写入信息，之后用某种方法擦除数据，可进行多次重写，但修改次数有限，写入时间很长。主要有UVEPROM(用紫外线照射一段时间，然后擦除==所有==信息)，以及EEPROM(用电擦除的方式，擦除特定的字)
- 闪速存储器(Flash Memory)：在EEPROM基础上发展而来，既可在不加电的情况下长期保存信息，又能在线进行多次快速擦除和重写，位密度比RAM高，注意由于闪存需要先擦除再写入，所以闪存写的速度比读的速度慢，如U盘、SD卡都是闪存
- 固态硬盘(SSD)：由控制单元和存储单元(Flash芯片)组成，可进行多次快速擦除重写，速度快、功耗低、价格高，目前个人电脑上常用SSD取代传统的机械硬盘

注：逻辑上主存由RAM+ROM组成，且二者常统一编址，因为主板上的BIOS芯片(ROM)存储了自举装入程序，负责引导装入操作系统(开机，一开始操作系统装在辅存中)。

### 4. 提高访存速度的措施

- 单体多字存储器：特点是存储器中只有一个存储体，但每个存储单元存储了m个字(多个字)，于是总线宽度也为m个字，一次并行读出m个字。缺点是指令和数据在主存内必须是连续存放的，一旦遇到转移指令，这种方法效果就不明显。
- 多体并行存储器

![](/zzimages/20230328135741.png)

![](/zzimages/20230328135747.png)

高位交叉编址实际上仍是顺序存储器，效果只是相当于单纯的扩容；而低位交叉编址则是交叉存储器，采用流水线方式并行存取，能大大提高存储器的带宽。

- 高性能存储芯片：如SDRAM，RDRAM，带Cache的DRAM(CDRAM)

## 3.3 主存与CPU的连接

### 1. 主存容量的扩展

- 位扩展
![](/zzimages/20230328135924.png)

- 字扩展
![](/zzimages/20230328135939.png)

CPU的地址线低位与存储芯片的地址线相连，而高位用作片选。

片选信号的产生分为线选法和译码片选法：线选法用每条线分别连到片选线，于是n条线只能对应n个片选信号；而译码片选法则将每条线通过地址译码器产生片选信号，于是n条线能够对应$2^n$个片选信号，更能节省地址资源。
- 字位同时扩展

### 2. 译码器

![](/zzimages/20230328140058.png)

## 3.4 辅助存储器

### 1. 磁盘存储器

#### 磁表面存储器的特点

存储容量大、位价低，记录介质可重复使用，非易失性，非破坏性读出；但存取速度慢，机械结构复杂，对工作环境要求较高。

#### 磁盘设备的组成

- 硬盘存储器的组成：磁盘驱动器、磁盘控制器、盘片
- 存储区域：一块硬盘含有若干记录面，每个记录面划分为若干磁道，每条磁道又划分为若干扇区，扇区(sector, 通常是512字节)是磁盘读写的最小单位，即磁盘按扇区存取
	- 磁头数：即记录面数，一个记录面对应一个磁头
	- 柱面数：表示硬盘每面盘片上有多少条磁道
	- 扇区数：表示每条磁道上有多少个扇区

注：一般扇区编号从最外圈磁道开始从0编号，而不同磁道间扇区往往会偏斜，以便磁头移动到下一个磁道时直接定位下一个块；现代磁盘驱动器外圈磁道通常比内圈磁道具有更多扇区；现代磁盘驱动器还有它的缓存(磁道缓冲区)，该缓存只是少量内存(通常8MB或16MB)，驱动器可以使用这些内存来保存从磁盘读取或写入磁盘的数据。

#### 磁盘的性能指标

- 磁盘的容量：一个磁盘所能存储的字节总数，有非格式化容量和格式化容量之分。非格式化容量是指磁记录表明可利用的磁化单元总数，由道密度和位密度计算而来；格式化容量是指按照某种特定的记录格式所能存储信息的总量，比非格式化容量小。
- 记录密度：盘片单位面积上记录的二进制信息量，通常以道密度、位密度和面密度表示。
	- 道密度：沿磁盘半径方向单位长度上的磁道数
	- 位密度：磁道单位长度上能记录的二进制代码位数，注意所有磁道记录的信息量一定是相等的，并不是圆越大信息越多，所以每个磁道的位密度都不同
	- 面密度：位密度和道密度的乘积
- 平均存取时间：由寻找时间、延迟时间和传输时间三部分构成。
	- 寻找时间(寻道时间)：磁头移动到目标磁道的时间。设启动磁头臂的时间为$s$, 移动磁头每跨越一条磁道的时间为$m$，共跨越$n$条磁道，则寻找时间$T_s=s+mn$.
	- 延迟时间(旋转延迟时间)：通过旋转磁盘使磁头定位到目标扇区的时间。设磁盘转速为$r$转/秒，则平均延迟时间为$T_R=1/(2r)$秒，因为找到目标扇区平均需要转半圈。
	- 传输时间：从磁盘读出或向磁盘写入数据所经历的时间。设磁盘转速为$r$，此次读$b$个字节，每个磁道上的字节数为$N$，则传输时间$T_t=b/(rN)$.
	
	注：由于延迟时间和传输时间都与磁盘转速相关，所以操作系统无法优化；但操作系统可以用磁盘调度算法优化寻道时间。通常比较驱动器用I/O速率(即传输大小除以平均存取时间)更容易。
	例：某磁盘转速为6000转/分，每个磁道有12个扇区，寻道的平均等待时间为10.5ms，试求磁盘平均存取时间。由于6000转/分=100转/秒，所以磁盘转一周用时10ms，平均旋转延迟时间即转半周的时间5ms，而传输时间即扫过一个扇区的用时为10/12=0.83ms，所以平均存取时间为10.5+5+0/83=16.33ms
- 最大数据传输率：磁盘存储器在单位时间内向主机传送最大数据的字节数。假设磁盘转速为$r$转/秒，每条磁道容量为$N$字节，则最大数据传输率为$D_r=rN$

#### 磁盘地址

|驱动器号|柱面(磁道)号|盘面号|扇区号|
|-|-|-|-|
例如系统中有4个驱动器，每个驱动器带一个磁盘，每个磁盘256个磁道、16个盘面，每个盘面划分为16个扇区，于是每个扇区地址可以用2+8+4+4=18位二进制代码表示。

#### 硬盘的工作过程：寻址、读盘/写盘

硬盘的读写操作时串行的，不能在同一时刻既读又写，也不能在同一时刻读两组数据或写两组数据，所以一般有并-串变换电路将来自总线的并行数据转换为串行

#### 磁盘的分类

根据磁头是否可移动分为固定头磁盘(每个磁道有一个磁头)和移动头磁盘(每个盘面只有一个磁头)；根据盘片是否可更换分为固定盘磁盘和可换盘磁盘。

#### 磁盘阵列

RAID(廉价冗余磁盘阵列)是指将多个独立的物理磁盘组成一个独立的逻辑盘，数据在多个物理盘上分割交叉存储、并行访问，具有更好的性能、容量和可靠性。分级如下：
- RAID0：无冗余和无校验的磁盘阵列(把连续多个数据块交替存放在不同物理磁盘的扇区中，几个磁盘交叉并行读写，扩大了存储容量，提高了数据存取速度，但RAID0没有容错能力)
- RAID1：镜像磁盘阵列(使两个磁盘同时读写，互为备份，若一个磁盘出现故障，可以从另一个磁盘中读出数据，但将两个磁盘当作一个磁盘使用，意味着容量减少一半)
- RAID2：采用纠错的海明码的磁盘阵列
- RAID3：位交叉奇偶校验的磁盘阵列
- RAID4：块交叉奇偶校验的磁盘阵列(用一个单独的磁盘存放奇偶校验块，在数据块的每一位上执行按位异或(第1个磁盘的1位异或第2个磁盘的1位异或….第n个磁盘的1位)，将每个按位异或的结果放入奇偶校验块的相应位置)
- RAID5：旋转奇偶校验的磁盘阵列(与RAID4类似，只是将奇偶校验块跨驱动器旋转，即每个奇偶校验块处在不同的磁盘上)

### 2. 光盘存储器

光盘存储器是利用光学原理读写信息的存储装置，采用聚焦激光束对盘式介质以非接触的方式记录信息。光盘存储系统分为光盘片、光盘驱动器、光盘控制器、光盘驱动软件。光盘的类型如下：
- CD-ROM：只读型光盘，只能读出其中内容，不能写入或修改
- CD-R：只可写入一次信息，之后不可修改
- CD-RW：可以重复读写
- DVD-ROM：高容量的CD-ROM，DVD表示通用数字化多功能光盘

### 3. 固态硬盘(SSD)

固态硬盘是基于闪存技术的半导体存储器，利用高性能Flash Memory作为硬盘来记录数据，与U盘没有本质上的差别，只是容量更大，存取性能更好。由于闪存是在EEPROM基础上发展起来的，所以本质上是只读存储器。

## 3.5 高速缓冲存储器

### 1. Cache的基本工作原理

Cache通常由SRAM构成。设一个程序执行期间，Cache的总命中次数为$N_c$，访问主存的总次数为$N_m$，则Cache命中率为$H=N_c/(N_c+N_m)$。设$t_c$是访问一次Cache所需的时间，$t_m$是访问一次主存所需的时间，则Cache-主存系统的平均访问时间$t$为：
> $t=Ht_c+(1−H)(t_c+t_m)$，如果采用先访问Cache，未命中再访问主存的方式;
> 
> $t=Ht_c+(1−H)t_m$，如果采用同时访问Cache和主存，命中则立即停止访问主存的方式。

我们用$e$来表示访问效率，即$e=\frac{t_c}{t}$.
为便于Cache和主存间交换信息，Cache和主存都被划分为相等的块，Cache的块又称行，主存的块又称页/页面/页框。于是CPU与Cache之间的数据交换以字为单位，而Cache与主存之间的数据交换则以块为单位。主存地址也拆分为块号+块内地址的形式。

### 2. Cache和主存的映射方式

- 直接映射
![](/zzimages/20230328142349.png)
	直接映射实现简单且无需替换算法，但空间利用率很低，产生块冲突概率高，命中率低

- 全相联映射
![](/zzimages/20230328142415.png)
	全相联映射比较灵活，空间利用率高，命中率也高，但标记的比较速度很慢，实现成本高，通常采用昂贵的按内容寻址的相联存储器进行地址映射

- 组相联映射
![](/zzimages/20230328142439.png)
	组相联映射相当于组间采用直接映射，组内采用全相联映射的方式，是一种折中，综合性能高。r路组相联是指每组有r个Cache块。

### 3. 替换算法(以全相联映射为例)

- 随机算法：随机确定替换的Cache块。实现简单，但完全没考虑局部性原理，命中率低
- 先进先出算法：选择最早调入的块进行替换。实现简单，但也不符合局部性原理
- 近期最少使用算法(LRU)：选择最久未访问过的块进行替换，基于局部性原理，命中率高，是堆栈类算法。LRU算法对每个Cache块设置一个计数器，用计数值来记录每个Cache块有多久未被访问，Cache满后替换计数值最大的块。具体地，
	> 命中时，所命中块的计数器清0，计数值比其低的计数器加1，其余不变
	> 
	> 未命中且还有空闲块时，新装入的块的计数器置0，其余非空闲块加1
	> 
	> 未命中且无空闲块时，计数值最大的块被替换，新装入的块计数器置0，其余全加1
	
	采用这一规则，在全相联映射下，如果Cache块总数为$2^n$，则计数器==只需要$n$位==，且Cache装满后所有计数器的值一定不重复(如果采用2k路组相联映射，则LRU算法所需的计数器位为k位)。但若被频繁访问的主存块数量大于Cache块的数量，可能会发生抖动，比如Cache块共4块，而访问地址为"0,1,2,3,4,0,1,2,3,4,…"
- 最不经常使用算法(LFU)：替换访问次数最少的存储块。每个块也设置一个计数器，新块建立后从0开始计数，每访问该块一次，计数器加1，Cache满后替换计数值最小的块，若有多个最小值，可按行号递增、或FIFO策略进行选择。该算法计数器所需位数可能会很大，而且也并没有很好遵循局部性原理，所以实际运行效果不如LRU。

### 4. Cache写策略

1. 对于Cache写命中，有两种处理方法：
	- 写回法：当CPU对Cache命中时，只把数据写入Cache，而不立即写入主存，只有当此块被替换出去时才写回主存。这种方法减少了访存次数，但存在数据不一致的隐患，同时要为每个Cache块设置一个修改位(脏位)用以记录是否进行过修改，以便在替换时判断是否要写回主存。
	- 全写法(写直通法)：当CPU对Cache写命中时，必须把数据同时写入Cache和主存，一般使用写缓冲减少全写法写入主存的时间损耗。

2. 对于Cache写不命中，也有两种处理方法：
	- 写分配法：当CPU对Cache写不命中时，把主存的块调入Cache中，然后在Cache中修改，通常搭配写回法使用。
	- 非写分配法：当CPU对Cache写不命中时，只写入主存，不调入Cache，通常搭配全写法使用

3. 现代计算机通常设立多级Cache，各级Cache间常采用全写法+非写分配法，而Cache与主存间常采用写回法+写分配法；除此之外，现代计算机也将指令Cache和数据Cache分开设计，从而减少指令流水线资源冲突

例：假设某个计算机的主存地址空间大小为256MB，按字节编址，其数据Cache有8个Cache行，行长为64B.
1. 若不考虑用于Cache的一致维护性和替换算法控制位，并且采用直接映射的方式，则该数据Cache的总容量为多少？
2. 若该Cache采用直接映射方式，则主存地址为3200(十进制)的主存块对应的Cache行号是多少？采用二路组相联映射时又是多少？
3. 以直接映射为例，简述访存过程(设访存的地址为0123456H)

解：
1. 如图，![](/zzimages/20230328143124.png)
	注意主存地址有28位(256MB)，其中6位是块内地址(64B)，3位是行号(8个Cache行)，所以剩余19位是标记为，总容量即为$8\times (1+19+512)=4256$位.
2. 直接映射方式中，3200对应的字块号为3200/64=50, 所以Cache行号为50 mod 8 = 2.二路组相联映射时，对应组号为50 mod 4 = 2，所以对应Cache行号为4或5.
3. 直接映射方式中，28位主存地址可分为19位主存标记位，3位的块号，6位的块内地址，即0000 0001 0010 0011 010 为主存标记位，001 为块号，010110为块内地址。所以首先根据块号查Cache(即001号Cache行)中对应的主存标记位，看是否相同。若相同，再看该Cache行的有效位是否为1，若是，则命中，按块内地址010110读出Cache行所对应的单元并送入CPU中，完成访存。若出现标记位不相等或有效位为0的情况，则不命中，访问主存将数据取出并送往CPU和Cache的对应块中，把主存地址的高19位存入001行的标记位中，并将有效位置1.

## 3.6 虚拟存储器

### 1. 虚拟存储器的基本概念

主存和辅存共同构成了虚拟存储器，对于应用程序员，虚拟存储器是透明的，它具有主存的速度和辅存的容量。虚拟存储器将主存或辅存的地址空间统一编址，形成一个庞大的地址空间，用户可以在这个空间内自由编程，而不必在乎实际的主存容量和程序在主存中实际的存放位置。用户编程允许涉及的地址称为虚地址或逻辑地址，虚地址对应的存储空间称为虚拟空间或程序空间；实际的主存单元地址称为实地址或物理地址，实地址对应的是主存地址空间，也称实地址空间。虚地址比实地址要大很多。CPU使用虚地址时，由辅助硬件找出虚地址和实地址之间的对应关系，并判断这个虚地址对应的存储单元内容是否已装入主存。若已在主存中，则通过地址变换，CPU可直接访问主存指示的实际单元；若不在主存中，则把包含这个字的一页或一段调入主存后再由CPU访问。若主存已满，则采用替换算法置换主存中的交换块(即页面)。

虚拟存储器也采用和Cache类似的技术，将辅存中经常访问的数据副本存放到主存中。但是缺页(或段)而访问辅存的代价很大，所以虚拟存储机制采用全相联映射提高命中率。此外，当进行写操作时，不能每次写操作都同时写回磁盘，所以采用写回法。

![](/zzimages/20230328143416.png)

### 2. 页式虚拟存储器

页式虚拟存储器以页为基本单位，虚拟空间与主存空间都被划分成同样大小的页，主存的页称为实页、页框，虚存的页称为虚页。

![](/zzimages/20230328143443.png)

![](/zzimages/20230328143449.png)

![](/zzimages/20230328143459.png)

![](/zzimages/20230328143505.png)

### 3. 段式虚拟存储器

![](/zzimages/20230328143517.png)

### 4. 段页式虚拟存储器

![](/zzimages/20230328143540.png)

# 第4章 指令系统

## 4.1 指令格式

### 按地址码数目分类

==零地址指令==

|OP|
|----|

- 不需要操作数的指令，如空操作(NOP)、停机(HLT)、关中断指令等
- 用在堆栈计算机中的零地址指令，两个操作数隐含存放在栈顶和次栈顶，计算结果压回栈顶，如子程序返回(RET)、中断返回(IRET)等

==一地址指令==

|OP|$A_1$|
|-|-|
- 单操作数指令，如加1、减1、求反、求补等。
	指令含义：OP($A_1$)→$A_1$ ，即按$A_1$地址读取操作数，进行OP操作后结果存回$A_1$，一共需要3次访存操作(取指→读$A_1$→写$A_1$)
- 需要两个操作数，但其中一个操作数隐含约定由ACC提供，运算结果也存放在ACC中
	指令含义：(ACC)OP($A_1$)→ACC ，一共需要2次访存(取指→读$A_1$)

==二地址指令==

|OP|$A_1$|$A_2$|
|-|-|-|
指令含义：($A_1$)OP($A_2$)→$A_1$ ，一共要4次访存(取指→读$A_1$(目的操作数)→读$A_2$(源操作数)→写$A_1$)

==三地址指令==

|OP|$A_1$|$A_2$|$A_3$(结果)|
|-|-|-|-|
指令含义：($A_1$)OP($A_2$)→$A_3$ ，一共要4次访存(取指→读$A_1$→读$A_2$→写$A_3$)

==四地址指令==

|OP|$A_1$|$A_2$|$A_3$(结果)|$A_4$(下址)|
|-|-|-|-|-|
指令含义：($A_1$)OP($A_2$)→$A_3$ ，下一条将要执行指令的地址为$A_4$. 一共要4次访存(取指→读$A_1$→读$A_2$→写$A_3$)

### 按指令长度分类

- 定长指令字结构：指令系统中所有指令的长度都相等(定长指令字结构执行速度快，控制简单)
- 变长指令字结构：指令系统中各种指令的长度不等

指令字长是指一条指令的总长度，取决于操作码长度、操作数地址码长度和操作数地址的个数。将指令字长等于机器字长的指令称为单字长指令，类似可定义半字长指令、双字长指令。

### 按操作类型分类

- 数据传送：寄存器之间的传送(MOV)、从内存单元读取数据到CPU寄存器(LOAD)、从CPU寄存器写数据到内存单元(STORE)等
- 算术逻辑操作：加(ADD)、减(SUB)、乘(MUL)、除(DIV)、比较(CMP)、增1(INC)、减1(DEC)；与(AND)、或(OR)、取反(NOT)、异或(XOR)等
- 移位操作：算术移位、逻辑移位、循环移位等
- 转移操作：无条件转移(JMP)、条件转移(BRANCH，JZ：结果为0，JO：结果溢出，JC：结果有进位)、调用(CALL)、返回(RET)、陷阱(TRAP)
- 输入输出操作：用于CPU寄存器和I/O端口之间的数据传送等

### 按操作码长度分类

- 定长操作码指令格式：在指令字的最高位部分分配固定的若干位表示操作码，一般n位操作码字段的指令系统最大能够表示$2^n$条指令。这种方式控制器的译码电路设计简单，但灵活性较低。
- 扩展操作码指令格式：在定长指令字结构下，采用可变长操作码(指令系统中各指令的操作码长度可变)。最常用的可变长操作码方法就是扩展操作码，这种方式指令种类丰富，但增加了指令译码和分析的难度，使控制器设计复杂化。

![](/zzimages/20230328145423.png)

![](/zzimages/20230328145428.png)

![](/zzimages/20230328145434.png)

## 4.2 指令的寻址方式

### 1. 指令寻址

寻找下一条要执行的指令地址，==始终由PC给出，每次取指令之后PC一定会自动加1==，指向下一条应该执行的指令，但也可能因跳跃寻址而改变PC的值。

- 顺序寻址：通过程序计数器PC加1(这里的1指的是1个指令字长，因指令长度、编址方式而不同)，自动生成下一条指令的地址
- 跳跃寻址：通过转移指令实现。由本条指令给出下条指令地址的计算方式，跳跃的地址分为绝对地址(由标记符直接得到)和相对地址(相对于当前指令地址的偏移量)，跳跃的结果是当前指令修改PC值，所以下一条指令仍然通过PC给出。

### 2. 数据寻址

指令中的地址码字段并不代表操作数的真实地址，这种地址称为形式地址A，形式地址结合寻址方式，可以计算出操作数在存储器中的真实地址，这种地址称为有效地址EA。数据寻址就是寻找本条指令地址码指明的有效地址。由于数据寻址的方式较多，所以在指令字段中，每个操作数地址前通常设有一个寻址特征字段，用来指明相应的寻址方式。

#### 直接寻址

指令字中的形式地址A就是操作数的真实地址EA，即EA=A。直接寻址的优点是简单，指令在执行阶段只访问一次主存，不需要专门计算操作数的地址；缺点是A的位数决定了该指令操作数的寻址范围，且操作数的地址不易修改。

#### 间接寻址

指令的地址字段给出的形式地址不是操作数的真实地址，而是操作数有效地址所在的存储单元的地址，也就是操作数地址的地址，即EA=(A)。以上是一次间接寻址，类似可定义多次间接寻址。

![](/zzimages/20230328145657.png)

主存字第一位为1时，表示取出的仍不是操作数的地址，于是要多次间接寻址，而主存字第一位为0时，表示取得的是操作数的地址。

间接寻址的优点是可以扩大寻址范围(有效地址EA的位数大于形式地址A的位数)，便于编制程序(方便完成子程序的返回)；缺点是指令在执行阶段要多次访存(一次间接寻址需两次访存，多次间接寻址需根据存储字的最高位确定访存次数)

#### 寄存器寻址

在指令字中直接给出操作数所在的寄存器编号，即EA=$R_i$。优点是指令在执行阶段不需要访存，只访问寄存器，指令字短且执行速度快，支持向量/矩阵运算；缺点是寄存器价格昂贵，在计算机中的寄存器个数有限。

#### 寄存器间接寻址

在寄存器$R_i$中给出的不是一个操作数，而是操作数所在主存单元的地址，即EA=($R_i$)。其特点是在指令的执行阶段需要访问主存1次，与一般间接寻址相比速度更快。

#### 隐含寻址

不是明显地给出操作数的地址，而是在指令中隐含操作数的地址。比如单地址的指令格式就不明显地在地址字段中指出另一个操作数的地址，而规定ACC作为另一个操作数地址。隐含寻址的优点是有利于缩短指令字长；缺点是需增加存储操作数或隐含地址的硬件。

#### 立即(数)寻址

形式地址A就是操作数本身，又称为立即数，采用补码表示。立即寻址特征用#表示。优点是指令在执行阶段不访问主存，指令执行时间最短；缺点是A的位数限制了立即数的范围。

#### 基址寻址

将CPU中基址寄存器BR的内容加上指令格式中的形式地址A而形成操作数的有效地址，即EA=(BR)+A. 其中既可采用专用的基址寄存器，此时指令格式如下

|OP|寻址特征|A|
|-|-|-|

也可以采用某个通用寄存器$R_0$，此时指令格式如下

|OP|寻址特征|$R_0$|A|
|-|-|-|-|

基址寄存器是面向操作系统的，其内容由操作系统或管理程序确定，在程序执行过程中，基址寄存器的内容不变(作为基地址)，形式地址可变(作为偏移量)。采用通用寄存器作为基址寄存器时，可由用户决定哪个寄存器作为基址寄存器，但其内容仍由操作系统确定。

基址寻址的优点是可扩大寻址范围(基址寄存器的位数大于形式地址A的位数)，用户也不必考虑自己的程序存于主存的哪个空间区域，因此有利于多道程序设计，并可用于编制浮动程序(整个程序在内存里边的浮动)；缺点是偏移量(形式地址A)的位数较短。

#### 变址寻址

有效地址EA等于指令字中的形式地址A与变址寄存器IX的内容之和，即EA=(IX)+A. 其中既可以采用专用的变址寄存器，也可用通用寄存器作为变址寄存器。变址寄存器是面向用户的，在程序执行过程中，变址寄存器的内容可由用户改变(作为偏移量)，形式地址A不变(作为基地址)。

变址寻址的优点是可扩大寻址范围(变址寄存器的位数大于形式地址A的位数)，在数组处理过程中，可设定A为数组的首地址，不断改变变址寄存器IX的内容，便可很容易形成数组中任一数据的地址，特别适合编制循环程序，偏移量(变址寄存器IX)的位数足以表示整个存储空间。

#### 相对寻址

把程序计数器PC的内容加上指令格式中的形式地址A而形成操作数的有效地址，即EA=(PC)+A. 其中A是相对于PC所指地址的位移量，可正可负，补码表示。例如当前指令存放地址为123H，指令字长为2B，则取出当前指令后PC的值加"1"(1个指令字长)，所以此时PC的值为125H，于是操作数的有效地址即为125+A.

相对寻址的优点是操作数的地址不是固定的，它随PC值的变化而变化，且与指令地址之间总是相差一个固定值，因此便于程序浮动(一段代码在程序内部的浮动)，相对寻址广泛应用于转移指令。

#### 堆栈寻址

![](/zzimages/20230328150114.png)

寄存器堆栈又称硬堆栈，成本高，容量小；从主存中划出一段区域来做堆栈是最合算且最常用的方法，称为软堆栈。注意其中(SP)+1或(SP)-1中的"1"与寄存器编号或主存编址方式有关，比如采用软堆栈，主存按字节编址，而栈中每个元素占32位，则SP中的值就应该±4

#### 总结

![](/zzimages/20230328150143.png)

## 4.3 程序的机器级代码表示

![](/zzimages/20230328150210.png)

![](/zzimages/20230328150223.png)

![](/zzimages/20230328150236.png)

![](/zzimages/20230328150248.png)

![](/zzimages/20230328150303.png)

![](/zzimages/20230328150316.png)

![](/zzimages/20230328150329.png)

![](/zzimages/20230328150342.png)

![](/zzimages/20230328150355.png)

![](/zzimages/20230328150409.png)

![](/zzimages/20230328150423.png)

![](/zzimages/20230328150436.png)

## 4.4 CISC和RISC

CISC(复杂指令系统计算机)：一条指令完成一个复杂的基本功能，典型的有采用x86架构的计算机，主要用于笔记本、台式机。传统CISC指令系统的测试表明，典型程序中80%的语句仅仅使用处理机中20%的指令。

RISC(精简指令系统计算机)：一条指令完成一个基本操作，多条指令组合完成一个复杂的基本功能，典型的有ARM、MIPS架构的计算机，主要用于手机、平板。

CISC与RISC的比较:
![](/zzimages/20230328150537.png)

RISC的优势在于：能更充分利用VLSI芯片的面积；更能提高运算速度；RISC便于设计，可降低成本，提高可靠性；有利于编译程序代码优化。但从指令系统兼容性看，CISC大多能实现软件兼容，但大多数RISC机不能与老机器兼容。事实上，现代CISC结构的CPU已经融合了很多RISC的成分。

# 第5章 中央处理器

## 5.1 CPU的功能和基本结构

### 1. CPU的功能

- 指令控制：完成取指令、分析指令和执行指令的操作，即程序的顺序控制
- 操作控制：产生完成每条指令所需的控制命令
- 时间控制：对各种操作加以时间上的控制
- 数据加工：对数据进行算术和逻辑运算
- 中断处理：对计算机运行过程中出现的异常情况和特殊请求进行处理

注：运算器的功能是对数据进行加工；控制器的功能是负责协调并控制计算机各部件执行程序的指令序列，包括取指令、分析指令、执行指令和中断处理等。

### 2. 数据通路的基本结构

- 专用数据通路方式

![](/zzimages/20230328210322.png)

![](/zzimages/20230328210328.png)

- CPU内部单总线方式(将所有寄存器的输入端和输出端都连接到一条公共的通路上，这种方式结构简单，容易实现，但数据传输存在较多冲突的现象，性能较低)

![](/zzimages/20230328210344.png)

### 3. 运算器的基本结构

- 算术逻辑单元ALU：主要功能是进行算术和逻辑运算
- 暂存寄存器：用于暂存从主存读来的数据，该数据不能存放在通用寄存器中，否则会破坏其原有内容
- 累加寄存器ACC：它是一个通用寄存器，用于暂时存放ALU运算的结果信息，可以作为加法运算的一个输入端。
- 通用寄存器组：如AX、BX、CX、DX、SP等，用于存放操作数(包括源操作数、目的操作数及中间结果)和各种地址信息等。SP是堆栈指针，用于指示栈顶的地址。
- 程序状态字寄存器PSW：保留由算术逻辑运算指令或测试指令的结果而建立的各种状态信息，如溢出标志、符号标志、零标志、进位标志等。PSW中的这些位参与并决定微操作的形成。
- 移位器：对操作数或运算结果进行移位运算。
- 计数器CT：控制乘除运算的操作步数。

### 4. 控制器的基本结构

- 程序计数器PC：用于指出下一条指令在主存中的存放地址。CPU根据PC的内容去主存中取指令。因程序中指令通常是顺序执行的，所以PC有自增功能。
- 指令寄存器IR：用于保存当前正在执行的那条指令。
- 指令译码器：仅对操作码字段进行译码，向控制器提供特定的操作信号。
- 存储器地址寄存器MAR：用于存放要访问的主存单元的地址。
- 存储器数据寄存器MDR：用于存放向主存写入的信息或从主存读出的信息。
- 时序系统：用于产生各种时序信号，它们都由统一时钟(CLOCK)分频得到。
- 微操作信号发生器：根据IR的内容(指令)、PSW的内容(状态信息)及时序信号，产生控制整个计算机系统所需的各种控制信号，其结构有组合逻辑型(硬布线控制器)和存储逻辑型(微程序控制器)两种。

## 5.2 指令执行过程

### 1. 指令周期

![](/zzimages/20230328210954.png)

![](/zzimages/20230328210959.png)

机器周期可视为所有指令执行过程中的一个基准时间。访问一次存储器的时间是固定的且较长，因此通常以存取周期作为基准时间，即内存中读取一个指令字的最短时间作为机器周期。如果存储字长等于指令字长，则取指周期等于机器周期。在一个机器周期里可以完成若干微操作，每个微操作都需要一定的时间，可用时钟信号来控制产生每个微操作命令。

为了区分不同的工作周期，在CPU内设置了4个标志触发器FE、IND、EX和INT，分别对应取指、间址、执行和中断周期，并以1状态表示有效。所以控制器可以根据指令周期的不同阶段来区分主存存储单元中存放的是指令还是数据。

### 2. 指令周期的数据流

- 取指周期(任务是根据PC中的内容从主存中取出指令代码并存放在IR中)

|操作|解释|
|----|----|
|(PC)→MAR|现行指令地址送至存储器地址寄存器|
|1→R|CU发出读命令(经控制总线)传到主存，启动主存做读操作|
|M(MAR)→MDR|将MAR(经地址总线传到主存)所指主存单元中的内容经数据总线读至MDR内|
|(MDR)→IR|将MDR中的内容(此时是指令)送至IR|
|OP(IR)→CU|指令的操作码送至CU译码|
|(PC)+1→PC|CU发出控制信号，形成下一条指令地址|

- 间址周期(任务是取操作数的有效地址)

|操作|解释|
|----|----|
|Ad(IR)→MAR或Ad(MDR)→MAR|将指令的地址码(形式地址)送至MAR|
|1→R|CU发出读命令(经控制总线)传到主存，启动主存做读操作|
|M(MAR)→MDR|将MAR(经地址总线传到主存)所指主存单元中的内容经数据总线读至MDR内|
|(MDR)→Ad(IR)|将有效地址送至指令寄存器的地址码字段。此操作在有些机器中可省略|

- 执行周期
执行周期的任务是取操作数，并根据IR中的指令字的操作码通过ALU操作产生执行结果。不同指令的执行周期操作不同，因此没有统一的数据流向。

- 中断周期(任务是处理中断请求)

|操作|解释|
|----|----|
|0→EINT|关中断，将允许中断触发器清零，该操作可直接由硬件线路完成|
|0→MAR|将特定地址0送至MAR(用于保存程序断点)。如果使用堆栈来保存断点，且进栈操作时先修改栈指针，后存入数据，则改为(SP)-1→SP，(SP)→MAR|
|1→W|CU发出写命令(经控制总线)传到主存，启动主存做写操作|
|(PC)→MDR|将PC的内容(程序断点)送至MDR|
|(MDR)→M(MAR)|将MDR的内容通过数据总线写入MAR(经地址总线传到主存)所指主存单元中|
|向量地址→PC|CU控制将中断服务程序的入口地址(由向量地址形成部件产生)送入PC|

### 3. 指令执行方案

一个指令周期通常要包括几个时间段(执行步骤)，每个步骤完成指令的一部分功能，几个依次执行的步骤完成这条指令的全部功能。
- 单指令周期：对所有指令都选用相同的执行时间来完成。此时每条指令都在固定的时钟周期内完成，指令之间串行执行。因此，指令周期取决于执行时间最长的指令的执行时间。对于那些本来可以在更短时间内完成的指令，要使用这个较长的周期来完成，会降低整个系统的运行速度。
- 多指令周期：对不同类型的指令选用不同的执行步骤。指令之间串行执行，但可选用不同个数的时钟周期来完成不同指令的执行过程。该方案需要更复杂的硬件设计。
- 流水线方案：指令之间可以并行执行的方案，称为流水线方案，其追求的目标是力争在每个时钟脉冲周期完成一条指令的执行过程，这种方案通过在每个时钟周期启动一条指令，尽量让多条指令同时运行，但各自处在不同的执行步骤中。

## 5.3 数据通路的功能和基本结构

数据通路是指数据在功能部件之间传送的路径，包括数据通路上流经的部件(不包括控制部件，因为数据通路是由控制部件控制的)。数据通路描述了信息从什么地方开始，中间经过哪些部件，最后传到哪里。数据通路由控制部件控制，控制部件根据每条指令功能的不同生成对数据通路的控制信号。数据通路的功能是实现CPU内部的运算器与寄存器及寄存器之间的数据交换。数据通路的基本结构主要有：CPU内部单总线方式、CPU内部多总线方式、专用数据通路方式。

![](/zzimages/20230328213336.png)

![](/zzimages/20230328213349.png)

![](/zzimages/20230328213401.png)

![](/zzimages/20230328213419.png)

## 5.4 硬布线控制器

根据控制器产生微操作控制信号的方式的不同，控制器可分为硬布线控制器和微程序控制器，两类控制器中的PC和IR是相同的，但确定和表示指令执行步骤的办法以及给出控制各部件运行所需要的控制信号的方案是不同的。硬布线控制器的基本原理是根据指令的要求、当前的时序及外部和内部的状态，按时间的顺序发送一系列微操作控制信号。它由复杂的组合逻辑门电路和一些触发器构成，因此又称组合逻辑控制器。硬布线控制器的特点是：指令越多，设计和实现就越复杂，因此一般用于RISC；如果扩充一条新的指令，则控制器的设计就需要大改，因此扩充指令较困难；由于使用纯硬件实现控制，因此执行速度很快，微操作控制信号由组合逻辑电路即时产生。

- 硬布线控制单元图
![](/zzimages/20230328213516.png)
为了简化控制单元CU的逻辑，将指令的操作码译码和节拍发生器从CU分离出来，指令译码器记为ID(Instruction Decoder). 注意事实上控制单元还接收来自系统总线(控制总线)的控制信号，如中断请求、DMA请求。
- 硬布线控制器的设计步骤分为：分析每个阶段的微操作序列、选择CPU的控制方式、安排微操作时序、电路设计

### 分析每个阶段的微操作序列

- 取指周期:
(PC)→MAR
1→R
M(MAR)→MDR
(MDR)→IR
OP(IR)→ID
(PC)+1→PC

- 间址周期:
Ad(IR)→MAR
1→R
M(MAR)→MDR
(MDR)→Ad(IR)

- 执行周期(不同指令各不相同)
- 中断周期:
0→EINT
0→MAR(假设程序断点存入主存0号地址单元内)
1→W
(PC)→MDR
(MDR)→M(MAR)
向量地址→PC

### CU的控制方式

- 同步控制方式：系统有一个统一的时钟，所有的控制信号均来自这个统一的时钟信号。通常以最长的微操作序列和最繁琐的微操作作为标准，采取完全统一的、具有相同时间间隔和相同数目的节拍作为机器周期来运行不同的指令。同步控制方式的优点是控制电路简单，缺点是运行速度慢。(以下我们以同步控制方式为例，假设一个机器周期含3个节拍，来设计硬布线控制器)
- 异步控制方式：各部件按自身固有速度工作，通过应答方式进行联络，速度快，但控制电路复杂。
- 联合控制方式：对各种不同的指令的微操作实行大部分采用同步控制、小部分采用异步控制的方法。
- 人工控制方式：在机器面板或内部设置一些开关或按键，如复位键、连续或单条执行转换开关、符合停机开关。

### 安排微操作时序

原则：微操作的先后顺序不得随意更改；被控对象不同的微操作尽量安排在一个节拍内完成；占用时间较短的微操作尽量安排在一个节拍内完成并允许有先后顺序。

- 取指周期:

|节拍|微操作|
|---|---|
|$T_0$|(PC)→MAR，1→R|
|$T_1$|M(MAR)→MDR，(PC)+1→PC|
|$T_2$|(MDR)→IR，OP(IR)→ID|
其中$T_0$和$T_1$的安排都遵循了第二个原则，而$T_2$的安排遵循了第三个原则，因为寄存器之间数据传送很快，占用时间很短。

- 间址周期:

|节拍|微操作|
|---|---|
|$T_0$|Ad(IR)→MAR，1→R|
|$T_1$|M(MAR)→MDR|
|$T_2$|(MDR)→Ad(IR)|

- 执行周期:
指令主要有：非访存指令(清除累加器指令CLA、累加器取反指令COM、算术右移一位指令SHR、循环左移一位指令CSL、停机指令STP)，访存指令(加法指令ADD、存数指令STA、取数指令LDA)，转移类指令(无条件转移指令JMP、有条件转移指令(负则转)BAN)。(注意累加器ACC也经常简写为AC)

- 中断周期:

|节拍|微操作|
|---|---|
|$T_0$|0→EINT，0→MAR，1→W|
|$T_1$|(PC)→MDR|
|$T_2$|(MDR)→M(MAR)，向量地址→PC|

### 电路设计

1. 列出操作时间表

![](/zzimages/20230328214328.png)

2. 写出微操作命令的最简表达式

![](/zzimages/20230328214348.png)

3. 画出逻辑图

![](/zzimages/20230328214511.png)

## 5.5 微程序控制器

### 1. 微程序控制的基本概念

![](/zzimages/20230328214547.png)

微程序控制器采用存储逻辑实现，也就是把微操作信号代码化，使每条机器指令转化为一段微程序并存入控制存储器中，微操作控制信号由微指令产生。
- 微命令与微操作：微操作是计算机中最基本的不可再分解的操作，而微命令是控制部件发出的各种控制命令。所以一个微命令对应一个微操作，即微命令是微操作的控制信号，微操作是微命令的执行过程。
- 微指令与微周期：微指令是若干微命令的集合，一个微指令可以完成多个微操作。存放微指令的控制存储器的单元地址称为微地址。一条微指令通常至少包含操作控制字段(又称微操作码字段，用于产生某一步操作所需的各种操作控制信号)和顺序控制字段(微地址码字段，用于控制产生下一条要执行的微指令地址)。微周期指从控制存储器中读取一条微指令并执行相应的微操作所需的时间。

### 2. 微程序控制器组成和工作过程

- 微程序控制器的基本组成(图中所画出的主要是微程序控制器比组合逻辑控制器多出的部件)
![](/zzimages/20230328214649.png)

- 微程序控制器的工作过程
![](/zzimages/20230328214711.png)

- 微程序和机器指令
![](/zzimages/20230328214728.png)

### 3. 微指令的编码方式

微指令的编码方式又称微指令的控制方式，是指如何对微指令的控制字段进行编码，以形成控制信号。编码的目标是在保证速度的情况下，尽量缩短微指令字长。

![](/zzimages/20230328214758.png)

![](/zzimages/20230328214804.png)

![](/zzimages/20230328214819.png)

### 4. 微指令的地址形成方式

- 直接由微指令的下地址字段指出，这种方式也称为断定方式。
- 根据机器指令的操作码形成。机器指令取至指令寄存器后，微指令的地址由操作码经微地址形成部件形成。
- 增量计数器法，即(CMAR)+1→CMAR，适用于后继微指令的地址连续的情况
- 根据各种标志决定微指令分支转移的地址
- 通过测试网络形成(测试网络即微程序控制器基本组成中的顺序逻辑)
- 由硬件直接产生微程序入口地址。如第一条微指令的地址可由专门的硬件电路产生，这个地址即为取指周期微程序首地址；又如中断周期微程序的首地址也可由硬件产生(由专门的硬件记录)。

![](/zzimages/20230328214915.png)

### 5. 微指令的格式

![](/zzimages/20230328214931.png)

微指令格式与微指令的编码方式有关，可见，直接编码、字段直接编码、字段间接编码和混合编码(直接编码和字段编码混合使用)都属于水平型微指令。

### 6. 微程序控制单元的设计步骤

1. 分析每个阶段的微操作序列
2. 写出对应机器指令的微操作命令及节拍安排
![](/zzimages/20230328215025.png)
![](/zzimages/20230328215033.png)

3. 确定微指令格式
![](/zzimages/20230328215052.png)

4. 编写微指令码点
![](/zzimages/20230328215106.png)

### 7. 微程序设计分类

![](/zzimages/20230328215122.png)

### 8. 硬布线和微程序控制器的特点

![](/zzimages/20230328215144.png)

微程序控制器的时序系统比较简单

## 5.6 指令流水线

### 1. 指令流水线的基本概念

可以从两方面提高处理机的并行性：一是时间上的并行技术，将一个任务分解为几个不同的子阶段，每个阶段在不同的功能部件上并行执行，以便在同一时刻能够同时执行多个任务，进而提升系统性能，这种方法被称为流水线技术；二是空间上的并行技术，在一个处理机内设置多个执行相同任务的功能部件，并让这些功能部件并行工作，这样的处理机被称为超标量处理机。

- 流水线的表示方法:
![](/zzimages/20230328215255.png)

- 指令流水的定义:
一条指令的执行过程可分解为若干阶段，每个阶段由相应的功能部件完成。如果将各阶段视为相应的流水段，则指令的执行过程就构成了一条指令流水线。一般将一条指令的执行过程分为如下5个流水段(即五级流水线)：取指(IF，从指令存储器或Cache中取指令)、译码/读寄存器(ID，操作控制器对指令进行译码，同时从寄存器堆中取操作数)、执行/计算地址(EX，执行运算操作或计算地址)、访存(MEM，对存储器进行读写操作)、写回(WB，将指令执行结果写回寄存器堆)。
![](/zzimages/20230328215321.png)

### 2. 流水线的性能指标

![](/zzimages/20230328215343.png)

![](/zzimages/20230328215348.png)

![](/zzimages/20230328215354.png)

### 3. 流水线的冒险与处理

在指令流水线中，可能会遇到一些情况使得流水线无法正确执行后序指令而引起流水线阻塞或停顿，这种现象称为流水线冒险。

- 结构冒险
![](/zzimages/20230328215426.png)

- 数据冒险
![](/zzimages/20230328215440.png)
数据冒险可分为三类：
> 写后读(RAW)相关：表示当前指令将数据写入寄存器后，下一条指令才能从该寄存器读取数据。否则，先读后写，读到的就是错误的旧数据。
> 读后写(WAR)相关：表示当前指令读出数据后，下一条指令才能写该寄存器。否则，先写后读，读到的就是错误的新数据。
> 写后写(WAW)相关：表示当前指令写入寄存器后，下一条指令才能写该寄存器。否则，下一条指令在当前指令之前写，将使寄存器的值不是最新值。

	在按序流动的流水线中(即不允许后进入流水线的指令超过先进入流水线的指令而先流出流水线)，只可能出现RAW相关。而非按序流动的流水线中，上述三种情况都可能发生。

- 控制冒险
![](/zzimages/20230328215630.png)

### 4. 流水线的分类

![](/zzimages/20230328215647.png)

![](/zzimages/20230328215652.png)

### 5. 高级流水线技术

![](/zzimages/20230328215715.png)

![](/zzimages/20230328215722.png)

![](/zzimages/20230328215728.png)

超标量流水线技术又称为动态多发射技术，超长指令字技术又称为静态多发射技术。
超流水线CPU在流水线充满后，每个时钟周期还是执行一条指令，CPI=1，但其主频更高；多发射流水线CPU每个时钟周期可以处理多条指令，CPI<1，相对而言，多发射流水线成本更高，控制更复杂。

### 6. 流水线的执行过程

![](/zzimages/20230328215804.png)

![](/zzimages/20230328215811.png)

![](/zzimages/20230328215816.png)

![](/zzimages/20230328215822.png)

![](/zzimages/20230328215828.png)

![](/zzimages/20230328215834.png)

## 5.7 多处理器的基本概念

### 1. SISD、SIMD、MIMD的基本概念

基于指令流的数量和数据流的数量，将计算机体系结构分为SISD、SIMD、MISD和MIMD四类。常规的单处理器属于SISD，而常规的多处理器属于MIMD。

- 单指令流单数据流结构(SISD)
SISD是传统的串行计算机结构，这种计算机通常仅包含一个处理器和一个存储器，处理器在一段时间内仅执行一条指令，按指令流规定的顺序串行执行指令流中的若干条指令。
- 单指令流多数据流结构(SIMD)
SIMD是指一个指令流同时对多个数据流进行处理，一般称为数据级并行技术。这种结构的计算机通常由一个指令控制部件、多个处理单元组成。每个处理单元虽然执行同一条指令，但各自有自己的地址寄存器，从而有不同的数据地址，即不同处理单元执行的同一条指令所处理的数据是不同的，比如对for循环处理数组很有效，而对switch语句却很低效(因为要根据不同的数据执行不同的操作)。
- 多指令流单数据流结构(MISD)
MISD是指同时执行多条指令，处理同一个数据，实际上不存在这样的计算机。
- 多指令流多数据流结构(MIMD)
MIMD是指同时执行多条指令分别处理多个不同的数据，MIMD分为多计算机系统和多处理器系统。多计算机系统中的每个计算机节点都具有各自的私有存储器，并且具有独立的主存地址空间，不能通过存取指令来访问不同节点的私有存储器，而要通过消息传递进行数据传送，也称消息传递MIMD。多处理器系统是共享存储多处理器系统(SMP)的简称，它具有共享的单一地址空间，通过存取指令来访问系统中的所有存储器，也称共享存储MIMD。

SIMD和MIMD是两种并行计算模式，其中SIMD是一种数据级并行模式，而MIMD是一种并行程度更高的线程级并行或线程级以上并行计算模式。

### 2. 硬件多线程的基本概念

在支持硬件多线程的CPU中，必须为每个线程提供单独的通用寄存器组、单独的程序计数器等，线程的切换只需激活选中的寄存器，从而省略了与存储器数据交换的环节，大大减少了线程切换的开销。硬件多线程有3种实现方式：
- 细粒度多线程：多个线程之间轮流交叉执行指令，多个线程之间的指令是不相关的，可以乱序并行执行。在这种方式下，处理器能在每个时钟周期切换线程。
- 粗粒度多线程：仅在一个线程出现了较大开销的阻塞时，才切换线程，如Cache缺失。在这种方式下，当发生流水线阻塞时，必须清除被阻塞的流水线，新线程的指令开始执行前需要重载流水线，因此，线程切换的开销比细粒度多线程大。
- 同时多线程(SMT)：是上述两种多线程技术的变体。它在实现指令级并行的同时，实现线程级并行，即它在同一个时钟周期中，发射多个不同线程中的多条指令执行。Intel处理器中的超线程(HT)就是同时多线程SMT，即在一个单处理器或单个核中设置了两套线程状态部件，共享高速缓存和功能部件。

### 3. 多核处理器的基本概念

多核处理器是指将多个处理单元集成到单个CPU中，每个处理单元称为一个核(core)。每个核可以有自己的Cache，也可以共享同一个Cache。所有核一般都是对称的，并且共享主存储器，因此多核处理器属于共享存储的对称多处理器。

在多核计算机系统中，如要充分发挥硬件性能，必须采用多线程(或多进程)执行，使得每个核在同一时刻都有线程在执行。与单核上的多线程不同，多核上的多个线程是在物理上并行执行的，是真正意义上的并行执行，在同一时刻有多个线程在并行执行，而单核上的多线程是一种多线程交错执行，实际上在同一时刻只有一个线程在执行。

### 4. 共享内存多处理器的基本概念

具有共享的单一物理地址空间的多处理器被称为共享内存多处理器(SMP)。处理器通过存储器中的共享变量互相通信，所有处理器都能通过存取指令访问任何存储器的位置。注意，即使这些系统共享同一个物理地址空间，它们仍然可在自己的虚拟地址空间中单独地运行程序。

单一地址空间的多处理器有两种类型。第一类，每个处理器对所有存储单元的访问时间是大致相同的，即访问时间与哪个处理器提出访存请求及访问哪个字无关，这类机器被称为统一存储访问多处理器(UMA)。第二类，某些访存请求要比其他的快，具体取决于哪个处理器提出了访问请求以及访问哪个字，这是由于主存被分割并分配给了同一机器上的不同处理器或内存控制器，这类机器被称为非统一存储访问多处理器(NUMA)。
- 统一存储访问多处理器：根据处理器与共享存储器之间的连接方式，分为基于总线、基于交叉开关网络和基于多级交换网络连接等几种处理器。
- 非统一存储访问多处理器：处理器中不带高速缓存时，被称为NC-NUMA；处理器中带有一致性高速缓存时，被称为CC-NUMA。

早期计算机内存控制器没有整合进CPU，访存操作需要经过北桥芯片，CPU通过前端总线和北桥芯片相连，这就是统一存储访问架构。随着CPU性能提升由提高主频转到增加CPU数量(多核、多CPU)，NUMA架构诞生，内存控制器被集成到CPU内部，每个CPU都有独立的内存控制器。每个CPU都独立连接到一部分内存，CPU直连的这部分内存被称为本地内存。CPU之间通过QPI总线相连，CPU可通过QPI总线访问其他CPU的远程内存。与UMA架构不同，在NUMA架构下内存的访问出现了本地和远程的区别，访问本地内存明显要快于访问远程内存。

由于可能会出现多个处理器同时访问统一共享变量的情况，在操作共享变量时需要进行同步，否则一个处理器可能会在其他处理器尚未完成对共享变量的修改时就开始使用该变量。常用方法是通过对共享变量加锁的方式来控制对共享变量互斥访问。在一个时刻只能有一个处理器获得锁，其他要操作该共享变量的处理器必须等待，直到该处理器解锁该变量为止。

# 第6章 总线

## 6.1 总线概述

### 1. 总线的基本概念

- 总线的定义：总线是一组能为多个部件分时共享的公共信息传送线路。分时和共享是总线的两个特点。分时是指同一时刻只允许有一个部件向总线发送信息，若系统中有多个部件，则它们只能分时地向总线发送信息。共享是指总线上可以挂接多个部件，各个部件之间互相交换的信息都可通过这组线路分时共享，多个部件可同时从总线上接收相同的信息。早期计算机外部设备较少时采用分散连接的方式，不易实现随时增减外设，所以为了更好解决I/O设备和主机之间连接的灵活性问题，计算机的结构从分散连接发展为总线连接。
- 总线上的设备：主设备指获得总线控制权的设备；从设备指被主设备访问的设备，它只能响应从主设备发来的各种总线命令。
- 总线特性：机械特性(尺寸形状)、电气特性(传输方向和有效的电平范围)、功能特性(每根传输线的功能：地址、数据、控制)、时间特性(信号和时序的关系)

### 2. 总线的分类

按数据传输格式分为串行总线和并行总线：
- 串行总线：只需一条传输线，成本低，广泛应用于长距离传输，应用于计算机内部可以节省布线空间；但是在数据发送和接收时要进行拆卸和装配，要考虑串行-并行转换问题
- 并行总线：总线的逻辑时序比较简单，电路实现容易；但信号线较多，占用更多布线空间，远距离传输成本高昂，工作频率较高时信号线之间会产生干扰，所以无法持续提升工作频率
注：总线工作频率相同时，串行总线传输速度比并行总线慢；但并行总线工作频率不能持续提高，而串行总线可以通过不断提高总线工作频率来提高传输速度，最终超过并行总线

按总线功能(总线连接的部件)分为片内总线、系统总线和通信总线：
- 片内总线：芯片内部的总线，如CPU芯片内部寄存器与寄存器之间、寄存器与ALU之间的公共连接线
- 系统总线：计算机系统内各功能部件(CPU、主存、I/O接口)之间相互连接的总线。按系统总线传输信息内容的不同，又分为3类：数据总线、地址总线和控制总线。
	> 数据总线(DB)用来传输数据信息，是双向传输总线，数据总线宽度与机器字长、存储字长有关。注意区分数据通路和数据总线：各个功能部件通过数据总线连接形成的数据传输路径称为数据通路，所以数据通路表示的是数据流经的路径，而数据总线是指承载的媒介。
	> 
	> 地址总线(AB)用来指出数据总线上的源数据或目的数据所在的主存单元或I/O端口的地址，是单向传输总线(由CPU输出)，其位数与主存地址空间大小和设备数量有关。
	> 
	> 控制总线(CB)用来传输控制信息，包括CPU送出的控制命令和主存(或外设)返回CPU的反馈信号，所以控制信号既有输出又有输入。对任一条控制线而言，它的传输是单向的，而对于控制总线总体来说，可认为是双向的。
	
- 通信总线：在计算机系统之间或计算机系统与其他系统(如远程通信设备、测试设备)之间传送信息的总线，通信总线也称外部总线。

按时序控制方式分为同步总线和异步总线

### 3. 系统总线的结构

- 单总线结构(多数被小型计算机或微型计算机所采用)
![](/zzimages/20230329142511.png)

- 双总线结构
![](/zzimages/20230329142525.png)

- 三总线结构
![](/zzimages/20230329142538.png)

- 四总线结构
![](/zzimages/20230329142552.png)

## 6.2 总线的性能指标

- 总线传输周期(总线周期)：指一次总线操作所需的时间，包括申请分配阶段、寻址阶段、传输阶段和结束阶段。总线传输周期通常由若干总线时钟周期构成，但有时一个总线时钟周期也可包含多个总线周期。
- 总线时钟周期：即机器的时钟周期。计算机有一个统一的时钟，以控制整个计算机的各个部件，总线也要受此时钟的控制。
- 总线工作频率：总线周期的倒数
- 总线时钟频率：总线时钟周期的倒数
- 总线宽度：又称总线位宽，它是总线上同时能够传输的数据位数，通常指数据总线的根数
- 总线带宽：总线的最大数据传输率，即单位时间内总线上最多可传输数据的位数
$$
\begin{align*}
总线带宽&=总线工作频率\times总线宽度(bit/s)\\
&=总线工作频率\times总线宽度/8 (B/s)
\end{align*}
$$
- 总线复用：指一种信号线在不同的时间传输不同的信息，因此可以使用较少的线传输更多的信息，从而节省空间和成本。
- 信号线数：地址总线、数据总线和控制总线3种总线的总和称为信号线数

![](/zzimages/20230329142912.png)

## 6.3 总线事务和定时

### 1. 总线仲裁方式

总线仲裁方式分为集中仲裁方式和分布仲裁方式。集中仲裁方式又分为以下三类：
- 链式查询：只需很少几根线，且容易扩充设备，但对电路故障敏感，且优先级低的设备可能很难获得请求
- 计数器定时查询：根据计数器的值确定优先级，所以设备优先级可变，这种方式对电路故障 不如链式查询方式敏感，但增加了设备地址线，控制较为复杂
- 独立请求方式：响应速度快，优先次序控制灵活(用排队器)，但控制线数量多，总线控制更复杂

![](/zzimages/20230329143021.png)

![](/zzimages/20230329143029.png)

### 2. 总线事务

总线事务是指从请求总线到完成总线使用的操作序列，它是一个总线周期中发生的一些列活动。总线周期分为以下4个阶段：

- 申请分配阶段：由需要使用总线的主设备提出申请，经总线仲裁机构决定下一传输周期的总线使用权授于某一申请者。也可将此阶段分为==传输请求==和==总线仲裁==两个阶段。
- 寻址阶段：取得了使用权的主设备通过总线发出本次要访问的从设备的==地址==及有关==命令==，启动参与本次传输的从设备。
- 传输阶段：主模块和从模块进行==数据交换==，数据由源模块发出，经数据总线流入目的模块
- 结束阶段：主模块的有关信息均从系统总线上==撤除==，让出总线使用权

### 3. 总线定时

总线定时是指总线在双方交换数据的过程中需要时间上配合关系的控制，这种控制称为总线定时，其实质是一种协议或规则。

- 同步定时方式(同步通信) 

![](/zzimages/20230329143239.png)

![](/zzimages/20230329143255.png)

- 异步定时方式(异步通信)

![](/zzimages/20230329143311.png)

![](/zzimages/20230329143317.png)

- 半同步通信

![](/zzimages/20230329143330.png)

- 分离式通信

![](/zzimages/20230329143344.png)

## 6.4 总线标准

总线标准是国际上公布的互连各个模块的标准，是把各种不同的模块组成计算机系统时必须遵守的规范。根据总线在计算机系统中的位置，可分为系统总线(与CPU直接相连)、局部总线(没有与CPU直接相连，通常是连接高速的北桥芯片，用于连接了很多重要的硬件部件)、设备总线/通信总线(通常由南桥芯片控制，用于连接计算机与计算机，或连接计算机与外部I/O设备)。

- 系统总线标准：ISA(并行)、EISA(并行)
- 局部总线标准：VESA(并行)、PCI(并行)、AGP(并行)、PCI-E(串行)
- 设备总线/通信总线标准：连接各种外设的有RS-232C(串行)、SCSI(并行)、PCMCIA(并行)、USB(串行)，连接硬盘的有IDE(并行)、SATA(串行)

# 第7章 输入输出系统

## 7.1 I/O设备

按使用特性分类：
- 人机交互类外部设备：鼠标、键盘、打印机等，数据传输速度慢
- 存储设备：移动硬盘、光盘等，数据传输速度快
- 网络通信设备：调制解调器等，数据传输速度介于上述二者之间

按传输速率分类：
- 低速设备：鼠标、键盘等
- 中速设备：激光打印机等
- 高速设备：磁盘等

按信息交换的单位分类：
- 块设备：如磁盘、磁带、光盘等，传输速率较高，可寻址，即对它可随机地读/写任一数据块，通常使用文件访问接口和语义。
- 字符设备：鼠标、键盘、串口等，传输速率较慢，不可寻址，以字节为单位顺序访问，通常使用文件访问接口和语义。
- 网络设备：如网卡、蓝牙、wifi等，格式化报文交换，通常使用socket访问接口和语义。

## 7.2 I/O接口

I/O接口又称I/O控制器、设备控制器，是主机和外设之间的交接界面，通过接口可以实现主机和外设之间的信息交换。

### 1. I/O接口的功能

- 数据缓冲：通过接口的数据缓冲寄存器(DBR)暂存数据，达到主机和外设工作速度的匹配
- 错误与状态检测：通过状态寄存器反馈设备的各种错误、状态信息，供CPU查用
- 控制与定时：接收从控制总线发来的控制信号、时钟信号
- 数据格式转换：提供计算机与外设的信号格式的转换功能，如串-并、并-串等格式转换
- 与主机和设备通信：实现主机-I/O接口-I/O设备之间的通信

### 2. I/O接口的基本结构和工作原理

![](/zzimages/20230329143812.png)

I/O端口是指接口电路中可被CPU直接访问的寄存器，主要有数据端口、状态端口和控制端口，若干端口加上相应的控制逻辑电路组成接口。CPU能对数据端口进行读写操作，对状态端口只能读，对控制端口只能写。对I/O端口的编址方式有两种：
- 统一编址：又称==内存映射方式==，是指把I/O端口当作存储器的单元进行地址分配，靠==不同的地址码==区分内存和I/O设备，这种方式CPU不需要设置专门的I/O指令，用统一的访存指令就可以访问I/O端口。优点是不需要专门的I/O指令，使CPU访问I/O的操作更灵活，还可使端口有较大的编址空间；缺点是端口占用存储器地址，使内存容量变小，外设寻址时间长
- 独立编址：又称I/O映射方式，I/O端口的地址空间与主存地址空间是两个独立的地址空间，因而无法从地址码的形式上区分，需要设置专门的==I/O指令==(由操作码、命令码和设备码构成)让CPU来访问I/O端口，即靠==不同的指令==区分内存和I/O设备。优点是使用专用I/O指令，程序编制清晰，I/O端口地址位数少从而地址译码速度快，I/O设备地址不占用主存地址空间；缺点是I/O指令类型少，一般只能对端口进行传送操作，程序设计灵活性差，需要CPU提供存储器读/写和I/O设备读/写两组控制信号，增加了控制逻辑电路的复杂性

### 3. I/O接口的类型

- 按数据传送方式可分为并行接口和串行接口
- 按主机访问I/O设备的控制方式可分为程序查询接口、中断接口和DMA接口
- 按功能选择的灵活性可分为可编程接口和不可编程接口

## 7.3 I/O控制方式：程序查询方式

程序查询方式的工作流程：
1. CPU执行初始化程序，并预置传送参数
2. 向I/O接口发出命令字，启动I/O设备
3. 从外设接口读取其状态信息
4. CPU不断查询I/O设备状态，直到外设准备就绪
5. 传送一次数据，一般为一个字
6. 修改地址和计数器参数
7. 判断传送是否结束，若未结束转第③步，直到计数器为0

这种控制方式下，CPU一旦启动I/O设备，就必须停止现行程序的运行，并在现行程序中插入一段程序。程序查询方式的主要特点是CPU有踏步等待现象，CPU与I/O串行工作。这种方式的接口设计简单、设备量少，但CPU在信息传送过程中要花费很多时间来查询和等待，而且在一段时间内只能和一台外设交换信息，效率大大降低。

## 7.4 I/O控制方式：程序中断方式

### 1. 中断和异常的概念

作用：中断和异常是让操作系统内核夺回CPU使用权的唯一途径，使CPU从用户态变为内核态

定义：异常也称内中断，与当前执行的指令有关，中断信号来源于CPU内部；中断也称外中断，与当前执行的指令无关，中断信号来源于CPU外部。

分类：
- 异常可分为故障、自陷和终止。故障(fault)通常是由错误条件引起，可能被内核程序修复，内核程序修复故障后会把CPU使用权还给应用程序让它继续执行下去，如非法操作码、缺页故障、运算溢出、整数除0等；自陷(陷阱、陷入、访管、trap)是一种事先安排的异常事件，用于在用户态下调用操作系统内核程序，此时会调用一条特殊的指令——陷入指令(它不是特权指令)，引发一个内部中断信号(执行陷入指令就意味着应用程序主动地将CPU控制权还给操作系统内核，如系统调用就是通过陷入指令完成的)；终止(abort)是指出现了使得CPU无法继续执行的硬件故障，内核程序无法修复该错误，因此一般不再将CPU使用权还给引发终止的应用程序，而是直接终止该应用程序，如控制器出错、存储器校验错、非法使用特权指令等。
- 外中断可分为可屏蔽中断和不可屏蔽中断。可屏蔽中断是指通过INTR线发出的中断请求，通过改变屏蔽字可以实现多重中断；不可屏蔽中断是指通过NMI线发出的中断请求，通常是紧急的硬件故障，如电源掉电等(此外，异常也是不能被屏蔽的)。时钟中断(由时钟部件发出的中断信号)、I/O中断(由I/O设备发出的中断信号)等都是外中断。每一条指令执行结束时，CPU都会例行检查是否有外中断信号。
故障异常和自陷异常属于软件中断(程序性中断)，终止异常和外中断属于硬件中断。外中断和自陷异常处理完后返回到下一条指令，故障异常处理完后返回到当前指令，而终止异常不会返回。

中断和异常的处理过程：CPU检测到中断信号后，根据中断信号类型去查询中断向量表，以此来找到中断处理程序(是内核程序，需要在内核态下运行)在内存中的存放位置。

### 2. 程序中断的工作流程

#### 中断请求

中断源向CPU发送中断请求信号。为记录中断事件并区分不同的中断源，中断系统需对每个中断源设置==中断请求标记触发器INTR==，当其状态为1时表示中断源有请求。这些触发器可组成中断请求标记寄存器，该寄存器可集中在CPU中，也可分散在各个中断源中。通过INTR线发出的是可屏蔽中断(关中断时不会被响应)，通过NMI线发出的是不可屏蔽中断(关中断时也会被响应)。(关中断的作用是实现原子操作(一气呵成完成接下来的一系列操作)，在程序状态字寄存器中IF=1表示开中断(允许中断)，IF=0表示关中断(不允许中断))

#### CPU响应中断的条件

对于外中断，CPU是在统一时刻即每条指令执行阶段结束前向接口发出中断查询信号，以获取I/O的中断请求，即CPU响应中断的时间是在每条指令执行阶段的结束时刻。CPU响应中断必须满足以下3个条件：
- 中断源有中断请求
- CPU允许中断即开中断（异常和不可屏蔽中断不受此限制）
- 一条指令执行完毕(异常不受此限制)，且没有更紧迫的任务

#### 中断响应判优

中断响应优先级是指CPU响应中断请求的先后顺序。中断判优可用硬件实现，如硬件排队器，也可以用软件实现，如查询程序(但速度较慢)。中断响应优先级如下：
1. 硬件故障中断优于软件中断
2. 不可屏蔽中断优于内部异常优于可屏蔽中断
3. DMA请求优于I/O设备传送的中断请求
4. 高速设备优于低速设备
5. 输入设备优于输出设备
6. 实时设备优于普通设备

注：中断优先级包括中断响应优先级和中断处理优先级。中断响应优先级在硬件线路上是固定的，不便改动。中断处理优先级可利用中断屏蔽技术动态调整，以实现多重中断(后文会介绍)

#### 中断处理过程(以单重中断为例)

==中断响应过程(中断隐指令)==(中断隐指令由硬件自动完成)：

![](/zzimages/20230329144651.png)

注1：保存断点时，异常指令通常并没有执行成功，异常处理后要重新执行，所以其断点是当前指令的地址；而中断的断点则是下一条指令的地址。
注2：异常大多采用软件查询法(CPU设置一个异常状态寄存器用于记录异常原因，操作系统使用一个统一的异常或中断查询程序，按优先级顺序查询异常状态寄存器，以检测异常和中断类型，先查询到的先被处理，然后转到相应的处理程序)，而中断可以采用软件查询法或硬件向量法(异常或中断处理程序的首地址称为中断向量，系统中的全部中断向量都存放在存储器的某个区域中，这个区域称为中断向量表；CPU响应中断后，通过识别中断源获得中断类型号，然后计算出对应中断向量的地址，再根据该地址从中断向量表中取出中断向量，即中断服务程序的入口地址，并送入PC，从而执行中断服务程序)。

==中断服务程序==：

![](/zzimages/20230329144722.png)

注：现场和断点，这两类信息都不能被中断服务程序破坏。现场信息因为用指令可直接访问，所以通常在中断服务程序中通过指令把它们保存到栈或特定存储单元中，即由软件实现；而断点信息由CPU在中断响应过程时自动保存到栈或指定单元中，即由硬件实现。

### 3. 多重中断和中断屏蔽技术

![](/zzimages/20230329144802.png)

中断屏蔽技术主要用于多重中断，CPU要具备多重中断的功能，须满足以下条件：
- 在中断服务程序中提前设置开中断指令
- 优先级别高的中断源有权中断优先级别低的中断源

中断处理优先级是指多重中断的实际优先级处理次序，可利用中断屏蔽技术动态调整(如果不使用中断屏蔽技术，则处理优先级和响应优先级相同)。每个中断源都有一个屏蔽触发器，1表示屏蔽该中断源的请求，0表示可以正常申请，所有屏蔽触发器组合在一起便构成一个屏蔽字寄存器，屏蔽字寄存器的内容称为屏蔽字。屏蔽字设置的规律：
- 每个中断源对应一个屏蔽字(在处理该中断源的中断服务程序时，屏蔽寄存器中的内容为该中断源对应的屏蔽字)
- 屏蔽字中1越多，处理优先级越高。每个屏蔽字中至少有一个1(至少要能屏蔽自身的中断)

![](/zzimages/20230329144903.png)

### 4. 程序中断方式

![](/zzimages/20230329144918.png)

例1：
![](/zzimages/20230329144940.png)

例2：若某设备中断请求的响应和处理时间为100ns，每400ns发出一次中断请求，中断响应所允许的最长延迟时间为50ns，则在该设备持续过程中，CPU用于该设备的I/O时间占整个CPU时间的百分比至少是多少？
解：每隔400ns发出一次中断请求，即使经过50ns延迟，仍可以在100ns内处理该中断请求，所以百分比为100/400=25%

例3：某设备以中断方式与CPU进行数据交换，CPU主频为1GHz，设备接口中的数据缓冲寄存器为32位，设备的数据传输率为50kB/s。若每次中断开销(包括中断响应和中断处理)为1000个时钟周期，则CPU用于该设备输入/输出的时间占整个CPU时间的百分比至多是多少？
解：由于设备的数据缓冲寄存器为32位，即一次中断可以传输4B数据，而设备传输率为50kB/s，即每秒需要12.5k次中断，每次中断开销为1000个时钟周期。CPU主频为1GHz，即每秒有1G个时钟周期，所以百分比为(12.5k×1000)/1G=1.25%

## 7.5 I/O控制方式：DMA方式

### 1. DMA控制器的功能和组成

DMA方式是一种完全由硬件进行成组信息传送的控制方式，它具有程序中断方式的优点，即在数据准备阶段，CPU与外设并行工作，缺点是CPU每发出一条I/O指令，只能读/写一个或多个连续的数据块。DMA方式在外设与内存之间开辟一条直接数据通道(但主存和I/O设备之间并没有直接的物理通路，而是通过I/O设备接口、系统总线及总线桥接部件等相连，建立一个信息可以相互通达的通路，这在逻辑上可视为直接相连的)，信息传送不再经过CPU，降低了CPU在传送数据时的开销，因此称为直接存储器存取方式。这种方式适用于磁盘、显卡、声卡、网卡等高速设备大批量数据的传送，它的硬件开销比较大。在DMA方式中，中断的作用仅限于故障和正常传送结束时的处理。

![](/zzimages/20230329145059.png)

![](/zzimages/20230329145107.png)

### 2. DMA的传送过程(预处理、数据传送、后处理)

![](/zzimages/20230329145122.png)

### 3. DMA方式的特点

![](/zzimages/20230329145141.png)

### 4. DMA的传送方式

![](/zzimages/20230329145155.png)

### 5. DMA方式和程序中断方式的区别

![](/zzimages/20230329145210.png)

## 7.6 I/O控制方式：通道控制方式

I/O通道是一种硬件，是专门负责输入/输出的处理机。通道可以识别并执行一系列通道指令，但与CPU相比，通道可以执行的指令很单一，并且通道程序是放在内存中的，即通道与CPU共享内存。

通道控制方式流程：首先CPU向通道发出I/O指令，指明通道程序在内存中的位置，并指明要操作的是哪个I/O设备，之后CPU就切换到其他进程执行了；然后通道执行内存中的通道程序(其中指明了要读入/写出多少数据及数据在内存中的位置等信息)；通道执行完规定的任务后，向CPU发出中断信号，之后CPU对中断进行处理。

通道控制方式的优点是CPU、通道、I/O设备可以并行工作，CPU干预的频率极低(通道会根据CPU的指示执行相应的通道程序，只有完成==一组数据块==的读/写后才会发出中断信号请求CPU干预)，因此资源利用率很高。缺点是实现复杂，需要专门的通道硬件支持。


